---
layout: post
category: [CS, OS ]
title: "파일 관리"
date:   2022-09-19 23:52:42 +0900
author: pino #Author's nick.
prevPart: _posts/2022-09-13-OS_001.md
nextPart: _posts/2022-09-21-OS_003.md #Next part.
---



# TL;DR (용어 정리)
- `파일` : 보조기억장치에 저장된 관련된 데이터 레코드들의 집합에 이름을 붙인 것
- `파일 속성` 또는 `파일 메타데이터` : 파일을 관리하기 위한 각종 정보들로 파일 자체의 내용은 아님 <br><br>

- `디렉터리` : 모여있는 파일의 정보를 담고 있는 `파일` 로 파일을 관리하고 추적하기 위해 사용함
- `절대 경로` : root 로부터 목적지까지의 절대적인 경로
- `상대 경로` : 현재 위치를 기준으로 목적지까지의 경로 <br><br>

- `파일 시스템` : 운영체제와 모든 데이터, 프로그램의 저장과 접근을 위한 기법을 제공하는 것
- `파티션` : 논리적인 디스크(Logical Disk). 연속된 저장 공간을 하나 이상의 연속되고 독립적인 영역으로 나누어 사용하도록 정의한 규약
- `마운트` : 여러 개의 파티션을 통합하는 명령어

<br><br>


# 파일 관리

- 프로세스 주소 공간에만 정보를 저장하면 다음과 같은 문제점이 발생한다.
  - 제한된 양만 저장이 가능하고,
  - 프로세스 종료시 정보가 사라지며
  - 다수의 프로세스가 동시에 정보에 접근하기 어렵다.<br>

- 따라서 `Long-term Information Storage` 의 필요성이 대두되었다.
  - `디스크`에 정보를 저장하면 메인 메모리보다 더 많은 정보를 저장할 수 있고,
  - 프로세스가 종료되어도 정보가 사라지지 않으며
  - 다수의 프로세스에서 정보를 동시에 접근할 수 있다. <br><br>


그렇다면 디스크에서 어떻게 정보를 찾고, 동기화 문제를 해결할 수 있을까?

이 문제를 `파일`이란 새로운 추상화를 통해 해결한다.<br>

즉, `파일 시스템`은 디스크에 존재하는 데이터를 저장하고 접근할 수 있는 기법을 제공한다. <br><br><br>

# 1. 파일

### 파일이란?

- "A named collection of related information"

- 파일이란 `보조기억장치`에 저장된 **관련된 데이터 레코드들의 집합**이다.<br><br>



> ☝️ 여기서 잠깐! <br>
>
> 그럼 PC에서 사용하는 `파일`이란 단어는 무엇일까? <br>
>
> PC에서의 파일은 **시스템 사용자가 이용할 수 있는 데이터의 실체**를 의미한다. <br>
>
> 그러나 사실 시스템도, 응용 프로그램도, 디스크에 저장되는 모든 단위는 파일이다. <br>
>
> 운영체제는 다양한 저장 장치를 동일한 단위로 구분하기 위해 `file`이라는 단위를 사용하는 것이다. 

<br>

- 모든 파일은 0과 1의 비트 패턴으로 이루어지고 크게 실행 파일과 데이터 파일로 나뉨
- 파일의 이름은 `파일 이름.확장자` 형태로 구성됨 <br><br>



+) **실행 파일**

- 운영체제가 메모리로 가져와 CPU를 이용하여 작업을 하는 파일

- 사용자의 요청으로 프로세스가 된 파일을 의미한다. <br><br>



+) **데이터 파일** 

- 실행 파일이 작업하는데 필요한 데이터를 모아놓은 파일

- 스스로 프로세스가 될 수 없고, 전송되거나 보관만 됨

- ex) 이미지 뷰어 프로그램의 사진 파일, 뮤직 플레이어의 음악 파일 등 <br><br>



### 파일의 설계

- 각 파일이 어떤 `속성`(파일 이름, 파일의 종류, 용량, 접근 시간 등)들을 가지게 할 것인지
- 각 파일에 저장될 데이터를 어떤 형식으로 저장하고 처리해야 효율적인지
- 파일을 어떤 `구조`로 편성할 것인지 <br>



위와 같은 파일의 `속성`, `연산`, `구조` 등은 운영체제마다 다르다.

<details>
<summary><b>파일의 속성 File Attribute</b></summary>
<div markdown="1">


![File_00](/assets/img/posts/cs/os/5-3_file_attribute.png) <br>
파일의 속성들은 각 `파일 헤더`에 기록되며, 운영체제는 파일 헤더를 `파일 테이블`에서 관리한다. 		<br><br>

- name : 확장자를 포함한 전체 이름을 의미
- type : 실행 파일, 동영상 파일, 사진 파일 등 확장자로 구분
- size : 파일 용량을 의미
- time : 파일 접근 시간을 의미하며 만든 시간, 변경 시간, 최근 열어본 시간 등으로 세분화 
- location : 파일의 위치, 이름과 확장자가 같은 두 파일은 한 디렉터리에 존재할 수 없음 
- accessibility : 파일의 접근 권한을 의미 <br>
- owner : 파일의 소유자라는 의미, 윈도우에는 거의 없지만 유닉스에서는 자주 사용됨 <br><br>


운영체제가 관리하는 파일 헤더 외에 데이터 파일마다 자신에게 필요한 속성을 따로 정의할 때 `고유 헤더`를 사용한다.

  </div>
</details>



<details>
<summary><b>파일의 연산 File Operation</b></summary>
<div markdown="1">       
파일 자체를 변경하거나, 파일의 내용을 변경하는 작업들을 말한다.<br><br>
![File_01](/assets/img/posts/cs/os/5-3_file_operation.png) <br>

  </div>
  </details>

<details>
<summary><b>파일의 구조 File Structure</b></summary>
<div markdown="1">       

### 순차 파일 구조
![File_03](/assets/img/posts/cs/os/5-3_file_fs_1.png) <br>
파일의 내용이 하나의 긴 줄로 늘어선 형태 <br><br>

#### 장점
- 모든 데이터가 순차적으로 기록되기 때문에 저장 공간 낭비가 없음
- 구조가 단순함
- 순서대로 데이터를 읽거나 저장할 때 매우 빠르다. <br>
  
#### 단점 
- 파일에 새로운 데이터를 삽입하거나 삭제할 때 오래 걸림
- 특정 데이터로의 이동 시 직접 접근이 어려워 데이터 검색에 적절하지 않음 <br><br>

### 인덱스 파일 구조
![File_04](/assets/img/posts/cs/os/5-3_file_fs_2.png) <br>
인덱스 테이블을 이용해 순차 접근과 직접 접근이 가능한 형태 <br>
현대의 파일 시스템은 인덱스 파일 구조로, 파일을 저장할 땐 순차 파일 구조로, 파일에 접근할 땐 인덱스 테이블을 보고 파일에 직접 접근한다.<br><br>

#### 장점
- 인덱스 테이블을 통해 다양한 접근이 가능
- 많은 양의 데이터를 처리할 때 효율적 <br>
  
#### 단점 
- 인덱스 테이블을 위한 추가 저장 공간이 필요
- 인덱스 참조 시간이 추가됨 <br><br>

  
### 집적 파일 구조
![File_05](/assets/img/posts/cs/os/5-3_file_fs_3.png) <br>
저장하려는 데이터의 특정 값에 어떤 관계를 정의해 물리적인 주소로 바로 변환하는 파일 구조 <br>
해시 함수를 이용해 직접 접근이 가능한데 실제로 많이 쓰이진 않는다.<br><br>

#### 장점
- 해시 함수를 이용해 주소를 변환하므로 데이터 접근이 빠르다 <br>
  
#### 단점 
- 해시 함수를 찾기 어렵다
- 해시 함수를 잘 찾아도 저장 공간이 낭비될 수 있다 <br><br>

  

</div>
</details>
<br><br>

# 2. 디렉터리

### 디렉터리란?

- 파일을 관리하고 추적하기 위해 사용하는 개념

- 관련있는 파일을 하나로 모아놓은 곳이다.
- 디렉터리는 여러 층으로 구성되고 최상위에 루트 디렉터리가 있다. <br><br>



> ☝️ 여기서 잠깐! <br>
>
> 디렉터리는 새로운 단위인가요? No! <br>
>
> `디렉터리`는 '모여있는 파일의 정보'를 담는 `파일` 입니다.

<br><br>

#### 경로

- `절대 경로` : 루트 디렉토리를 기준으로 파일의 위치를 나타내는 방식 <br>
   ex) /program/data/exam.c

- `상대 경로` : 현재 있는 위치를 기준으로 파일의 위치를 표시 <br>
   ex) data/exam.c <br><br>



#### 디렉터리 구조

<details>
<summary>디렉터리의 구조</summary>
<div markdown="1">       

### 1단계 디렉터리 구조

![File_06](/assets/img/posts/cs/os/5-3_file_ds_1.png) <br>

가장 간단한 구조의 디렉터리로 각 파일은 사용자가 다르더라도 서로 유일한 이름을 가져야 한다. <br>

파일이 많아지거나 다수의 사용자가 사용하면 심각한 제약이 따른다. <br><br>



### 2단계 디렉터리 구조

![File_07](/assets/img/posts/cs/os/5-3_file_ds_2.png) <br>

사용자 별로 디렉터리를 만들어 관리하는 방법이다. <br>

사용자의 이름이나 계정 번호로 색인을 하고, 각 엔트리는 사용자 파일 디렉터리를 가리킨다. <br>

파일 참조 시 사용자의 파일 디렉터리에서만 탐색하므로 파일 이름 충돌 문제가 발생하지 않지만, 다른 사용자 파일에 접근해야 할 경우 단점이 된다. <br><br>



### 트리 디렉터리 구조

![File_08](/assets/img/posts/cs/os/5-3_file_ds_3.png) <br>

2단계 디렉터리 구조를 확장해 다단계 트리 구조로 만든다. <br>

사용자들이 자신의 서브 디렉터리를 만들어 파일을 구성할 수 있도록 한다. <br>

디렉터리의 각 항목은 일반 파일인지(0) 디렉터리 파일인지(1) 항목을 추가해 구분한다. <br><br>



### 그래프 디렉터리 구조

![File_09](/assets/img/posts/cs/os/5-3_file_ds_4.png) <br>

디렉터리들이 서브 디렉터리와 파일을 공유할 수 있도록 허용한다. <br>

트리 구조의 디렉터리를 일반화한 방식으로 `링크` 라고 불리는 새로운 디렉터리 항목을 통해 파일을 공유한다.



</div>
</details>

<br><br>
# 3. 파일 시스템

파일 시스템은 디스크에 존재하는 데이터를 저장하고 접근할 수 있는 방법을 말한다.<br>

- 컴퓨터 내 다양한 파일은 하드디스크나 CD 같은 저장 장치에 보관하는데,
- 이러한 파일들을 `파일 관리자` 를 두어 저장 장치의 전체 관리를 맡긴다. => `파일 시스템`
- 파일 관리자는 파일 테이블을 이용해 파일을 관리하고,
- 파일 읽기, 쓰기, 실행과 같은 다양한 접근 방법을 제공한다.
- 이때 권한이 필요한데 이를 파일 디스크럽터(File Descriptor)라고 한다. <br>

<details>
<summary><b>파일 디스크립터</b></summary>
<div markdown="1">

파일 디스크럽터란 유닉스 계열의 시스템에서 프로세스가 파일을 다룰 때 사용하는 개념으로, 프로세스에서 특정 파일에 접근할 때 사용하는 추상적인 값이다.

- 프로세스가 실행 중에 파일을 Open하면 
- 커널은 해당 프로세스의 파일 디스크립터 숫자 중 사용하지 않는 가장 작은 값을 할당해준다. 
- 그 다음 프로세스가 열려있는 파일에 시스템 콜을 이용해서 접근할 때, 파일 디스크립터(FD)값을 이용해서 파일을 지칭할 수 있다.
  

</div>
</details>
<br><br>

#### 블록

- 블록은 저장 장치에서 사용하는 가장 작은 단위로 한 블록에 주소 하나가 할당되고,

- 데이터는 운영체제와 저장장치 간에 블록 단위로 전송된다.
- 블록의 크기는 시스템마다 다름 (시스템이 정한 기본 크기를 사용하거나 직접 지정)
- 블록 크기를 너무 작게 설정하면 내부 단편화 현상이 줄어들지만 파일이 여러 블록으로 나뉘어 파일 입출력 속도가 느려진다. <br><br>



## Layout

![File](/assets/img/posts/cs/os/5-3_file_layout_0.png)

UNIX의 파일 시스템은 위와 같다. <br>

하나씩 살펴보자.

<details>
<summary><b>Depth 1 - Hard Disk</b></summary>
<div markdown="1">

![File](/assets/img/posts/cs/os/5-3_file_layout_1.png) <br>

하드 디스크는 다음으로 구성된다.

- MBR(Master Boot Record) : 기억 장치의 첫 섹터로 부팅에 사용된다.
- Partition table : 각 파티션의 정보가 담긴 테이블
- Disk Partition ( Partition1, Partition2, ....) : 각 파티션은 독립적인 `파일 시스템`이다.<br><br> 

</div>
</details>

<br><br>




<details>
<summary><b>Depth 2 - Partition </b></summary>
<div markdown="1">

![File](/assets/img/posts/cs/os/5-3_file_layout_2.png) <br>

하드 디스크 내 하나의 파티션(파일 시스템)은 다음으로 구성된다.

- Boot block
- Super block : 파일 시스템에서 가장 중요한 정보들
  - Magic number : 파일 시스템 타입을 식별하기 위한 정보
  - block의 수 
  -  ...
- Free space mgmt : `bitmap` or `pointer list`
- I-nodes : 파일 블록의 속성과 디스크 주소를 갖고 있는 정보들 (메타데이터)
  - 파일의 이름은 디렉터리 파일 데이터 블록에 있고, 나머지 메타 데이터는 I-node에 저장된다.
  - UNIX 에서는 I-nodes 방식을 사용하지만  파일 시스템에서 파일을 어떻게 구현할 것이냐에 따라 달라진다.
  
- Root dir : 최상단의 정보
- Files and directories : 실제 데이터들 <br><br>

</div>
</details>

<br><br>


## 파일 시스템 내 파일 구현 (Implementing Files)

### 1) Contiguous Allocation

파일을 연속된 디스크 블록에 저장하는 방법<br>

#### 장점

- 구현이 쉽다. (시작 주소와 block 개수만 알면 끝)
- 연속적으로 읽기 때문에 Read Performance가 좋다. <br>

#### 단점

- 디스크 외부 단편화<br><br>

=> CD-ROM처럼 파일 사이즈에 변화가 없는 시스템, 또는 동영상 서버처럼 파일 변경 없이 읽기만 하는 경우에 유용하다.<br><br>

### 2) 연결 할당 방식 

![File_11](/assets/img/posts/cs/os/5-3_file_09.png)

파일에 속한 데이터를 연결 리스트로 관리하는 방식<br>

#### 장점

- 디스크 외부 단편화가 없다 (물론 Internal은 항상 존재)
- 모든 디스크 블록을 사용할 수 있게 된다. <br><br>

#### 단점

- Random 접근이 매우 느리다. (뒷 block 읽으려면 모든 block을 디스크 접근으로 읽어야 한다.)
- pointer로 사용될 몇 바이트 때문에 저장되는 데이터의 양이 block 2개가 될 수 있다.<br><br>

### 3) 파일 테이블을 이용한 불연속 할당 (FAT)

![File_12](/assets/img/posts/cs/os/5-3_file_10.png)

- File Allocation Table(FAT)을 메모리에다 저장해둔다.

  연결리스트에서 다음 블록을 가리키는 포인터 정보만 빼다가 테이블 만든 것<br>

  -> Random access 가 쉬워진다. Disk access 아닌 Mem access로 해결되니까. <br>

- 파일의 위치만 FAT에 저장하고, 나머지 메타데이터는 디렉터리 데이터 블럭에 담는다.

#### 단점

- 하나의 파티션이 사용할 수 있는 디스크 용량이 테이블의 주소 크기로 제한된다.

  ex) FAT16은 16bit 주소 → 32GB

- FAT 이 작지 않기 때문에 공간 차지를 꽤 하고, 

- FAT 이 깨지거나 망가지면 시스템이 다 날아가기 때문에 Fault에 취약함<br><br>

### 4)인덱스를 이용한 불연속 할당 (Index-node)

![File_13](/assets/img/posts/cs/os/5-3_file_11.png)

- 테이블의 블록 포인터가 데이터 블록을 연결하는 것이 아니라, 데이터의 인덱스를 담고 있는 **인덱스 블록**(**inode**)을 연결
- 인덱스 노드는 파일 하나당 한 개씩 배치되고, 파일이 오픈될 때 메모리에 올린다.
- 인덱스 블록은 실제 데이터의 위치에 관한 정보를 순서대로 보관
- 테이블이 꽉 차서 더 이상 데이터를 연결할 수 없을 때는 인덱스 블록을 연결하는 간접 인덱스 블록(. index block)을 만들어 테이블을 확장할 수 있음 <br><br>



> ☝️ 여기서 잠깐! <br>
>
> 운영체제별 사용하고 있는 파일 시스템을 한 번 살펴보자. <br>
>
> - Windows : FAT(12/16/32), NTFS
> - Linux : ext(2/3/4)
> - MacOS : HFS, HFS+, APFS
> - Google : GFS (구글 사내에서 사용하기 위한 파일 시스템)
>
> <br>이렇듯 운영체제별로 파일 시스템이 다르기 때문에 파일 읽기/쓰기/실행이 꼬이는 것이다.

<br>

<details>
<summary><b> 운영체제별 파일 시스템 </b></summary>

<div markdown="1">

#### FAT (File Allocation Table)
- FAT에 파일의 위치를 기록하고 관리한다.
- 저용량에 적합하고 보안성이 좋지 못하지만, 다양한 운영체제에서 지원해 호환성이 좋다.
  
#### NTFS
- FAT을 보완하기 위해 만들어진 윈도우 계열의 파일 시스템
- FAT이 아닌 MFT(Master File Table) 사용
- 이에 대한 미러와 파일 로그가 유지되어 파일 복구 가능하다.
- 대용량도 지원하고 보안과 암호화 또한 지원하지만, 다른 운영체제와 호환이 안된다.
  
#### EXT2 
- 리눅스를 위한 확장성 있고 강력한 파일 시스템
- fsck를 이용해 파일 복구에 매우 강하다.
- 캐시에 저장되어 있는 데이터들을 디스크로 저장하는 도중에 문제가 발생하면 파일 시스템이 손상된다.
  -> EXT3에선 저널링 이용해 파일 시스템 수정 전 저널에 수정 사항을 먼저 기록하는 것으로 해결
  
  

</div>
</details>



# 추가 정보

### 빈공간 리스트

- 파일 시스템은 디스크의 빈 공간을 효율적으로 관리하기 위해 **빈 블록의 정보만 모아놓은 빈 공간 리스트**를 유지
- 파일 테이블의 헤더를 삭제하고 사용했던 블록을 빈 공간 리스트에 등록하는 것을 파일이 삭제된 것으로 간주
- 어떤 데이터를 지우고 새로운 데이터를 디스크에 넣을 때 방금 지워진 블록에 할당되는 것이 아니라 리스트에 있던 블록 중 맨 앞에 있는 블록에 할당 <br><br>


`Free space mgmt` :  파일 시스템 내 디스크의 자유 공간을 어떻게 유지하고 관리할 것인지를 지정하는 변수

- Bitmap : 자유 공간(블락)의 리스트를 비트 맵을 구현
- list of pointer : 자유 공간을 링크드 리스트 형태로 연결시켜 가지고 있기 <br><br>



### 파일 복사

#### Hard Link

- 디렉터리 I-node에 해당 파일의 주소를 기록한다. (Point to same I-node)



#### Symbolic Link

- Link 유형의 새 파일을 만들어서 링크하고자 하는 파일의 경로 이름을 기록한다.

- 실제 파일의 owner 만 i-node를 가리키는 포인터를 갖고 있고, 링크한 다른 사용자들은 경로 이름만 가지고 있게 된다.

- Symbolic Link는 쉽게 말하면 `바로가기` 와 같다. 

- 서로 다른 경로에 위치해 있지만 같은 File을 사용하도록 하는 Sharing 기법인 셈이다.<br><br>



### File Protection
#### Access Control
- Access control list : 파일에 대한 사용자의 접근 권한을 표시한다.
- Capability : 사용자별 접근 권한을 가진 파일과 권한을 표시한다.
<br>

#### Grouping
- 전체 사용자를 owner, group, public 세 그룹으로 구분한다.
- 각 파일에 대해 세 그룹의 접근 권한을 3비트씩 표시한다.
- UNIX 에서 사용하는 방식
<br>

#### Password
- 파일마다 password 를 두는 방법
- 암기 문제와 관리 문제가 발생한다.
<br><br>

### 파일 시스템 백업 / 성능

_(너무 딥해서 추가하지 않은 주제)_ <br><br><br><br>





# 예상 질문


<br><br>


# References

- [cs-study-파일관리](https://github.com/workhardslave/cs-study/blob/main/OS/%ED%8C%8C%EC%9D%BC%20%EA%B4%80%EB%A6%AC.md)
- [tech-interview-for-developer-파일시스템](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Operating%20System/File%20System.md)

- [공룡책 10.파일시스템 정리](https://noep.github.io/2016/02/23/10th-filesystem/)

- [파일의 기본 개념 - 파일의 종류 (1)](https://goodgid.github.io/FP-Basic-Concepts-Of-Files-(1)/)

- [파일의 설계](https://blog.naver.com/syunjae21/222072152255)
- [파일 편성 방법](https://blog.naver.com/syunjae21/222083168255)
- [운영체제별 파일 시스템](https://coconuts.tistory.com/775)
- [운영체제 파일 시스템 구현 그림들](https://scslab-intern.gitbooks.io/linux-kernel-hacking/content/chapter13.html)
