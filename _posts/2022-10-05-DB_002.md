---
layout: post
category: [CS, DB]
title: "DBMS / 외래키 / 정규화"
date:   2022-10-05 23:52:42 +0900
author: pino #Author's nick.
nextPart: _posts/2022-10-05-DB_003.md #Next part.
prevPart: _posts/2022-10-05-DB_001.md #Previous part.
---





# TL;DR

- DB : 데이터의 저장소
- DBMS : 데이터 베이스를 운영하고 관리하는 소프트웨어
- 외래키 : 다른 테이블의 기본키를 참조하는 키로 테이블 연결, 중복 방지, 무결성 유지를 위해 사용
- 정규화 : 테이블 간에 중복된 데이타를 허용하지 않음으로 무결성을 유지하기
- 역정규화 : 테이블 간에 중복된 데이터를 허용함으로 성능 향상시키는 최적화 기법

<br><br><br>

# 데이터베이스 DB

데이터베이스가 존재하기 이전에는 파일 시스템을 이용해 데이터를 관리했는데, 어플리케이션 별로 데이터를 관리하게 되면 데이터 `종속성`, `중복성`, `무결성` 문제가 있었다.

<br>

#### 데이터베이스 특징

1. 데이터의 독립성
   - 물리적 독립성 : 데이터베이스 사이즈를 늘리거나 성능 향상을 위해 데이터 파일을 늘리거나 새롭게 추가하더라도 관련된 응용 프로그램을 수정할 필요가 없다.
   - 논리적 독립성 : 데이터베이스는 논리적인 구조로 다양한 응용 프로그램의 논리적 요구를 만족시켜줄 수 있다.
2. 데이터의 무결성
   여러 경로를 통해 잘못된 데이터가 발생하는 경우의 수를 방지하는 기능으로 데이터의 유효성 검사를 통해 데이터의 무결성을 구현하게 된다.
3. 데이터의 보안성
   인가된 사용자들만 데이터베이스나 데이터베이스 내의 자원에 접근할 수 있도록 계정 관리 또는 접근 권한을 설정함으로써 모든 데이터에 보안을 구현할 수 있다.
4. 데이터의 일관성
   연관된 정보를 논리적인 구조로 관리함으로써 어떤 하나의 데이터만 변경했을 경우 발생할 수 있는 데이터의 불일치성을 배제할 수 있다. 또한 작업 중 일부 데이터만 변경되어 나머지 데이터와 일치하지 않는 경우의 수를 배제할 수 있다.
5. 데이터 중복 최소화
   데이터베이스는 데이터를 통합해서 관리함으로써 파일 시스템의 단점 중 하나인 자료의 중복과 데이터의 중복성 문제를 해결할 수 있다.

<br><br>

## DBMS

- 데이터베이스 관리 시스템 (DataBase Management System)
- 데이터베이스의 데이터에 접근하여 사용할 수 있도록 해주는 소프트웨어
- 정의, 조작, 제어 기능 수행
  - 정의 DDL : DB 구조 정의(테이블, 속성)
    - Create, Alter, Drop
  - 조작 DML : DB 연산 처리(수정, 삭제, 검색)
    - Select, Insert, Delete, Update
  - 제어 DCL : 데이터 무결성 및 일관성 유지, 접근 권한 부여, 동시성 제어
    - Commit, Rollback, Grant, Revoke

<br>

#### DBMS 종류

- 계층형 DBMS(HDBMS, Hierarchical DBMS)

  - 처음 등장한 DBMS 개념으로 1960년대 시작됨.

  - 트리 형태

  - 처음 구성 완료 후 이를 변경하기 까다로움. → 현재는 사용하지 않음.

- 망형 DBMS (NDBMS, Network DBMS)

  - 계층형 DBMS의 문제점 개선을 위해 1970년대 등장

  - 하위 구성원들끼리도 관계를 갖는 유연한 구조로, 네트워크상의 노드로 데이터 구조를 표현하여 각각 노드가 서로 대등한 관계로 구성됨.

  - 구성과 설계가 복잡하고 궁극적으로 데이터 종속성의 문제를 해결하지 못했다.

    > **👆 데이터 종속성 문제란? (Data Dependency)** 프로그램의 구조가 데이터 구조에 영향을 받는 것을 의미.

- **관계형 DBMS** (RDBMS, Relational DBMS)

  - `테이블` 이라는 최소단위로 구성되며, `열`과 `행`으로 이루어져 있다.

  - SQL을 이용해 `속성(열)에 맞는 자료형`으로 데이터 삽입

    > **👆 SQL(Structured Query Language)** 
    >
    > RDBMS에서 사용되는 언어로 특정 회사에서 만드는게 아니라 `국제표준화기구`에서 SQL에 대한 표준을 정해서 발표하고 있음. 
    > 이를 `표준SQL` 이라고 함.

  - 트랜잭션(Transaction) 보장

    : 다수 사용자가 데이터베이스를 동시에 접근하도록 허용하면서 데이터 베이스가 일관성을 유지하게 하는 기술

    > 👆 트랜잭션의 특징 ACID
    >
    > - **Atomicity(원자성)** : 트랜잭션의 처리가 완전히 끝나지 않았을 경우에는 전혀 이루어지지 않은 것과 같아야 한다(all or nothing).
    > - **Consistency(일관성)** : 트랜잭션의 실행이 성공적으로 완료되면 데이터베이스는 모순 없이 일관성이 보존된 상태여야 한다.
    > - **Isolation(격리성)** : 현재 수행중인 트랜잭션이 완료될 때 까지 트랜잭션이 생성한 중간 연산 결과에 다른 트랜잭션들이 접근할 수 없다.
    > - **Durability(지속성)** : 트랜잭션이 성공적으로 완료된 후 데이터베이스에 반영한 수행 결과는 어떠한 경우에도 손실되지 않고 영구적이어야 한다.

  - 데이터 무결성 보장, 데이터를 중복 없이 저장

  - 기존의 스키마 수정이 어려움, 데이터가 자주 변경되거나 명확한 스키마가 있는 경우 사용

- **비관계형 DBMS (NoSQL)**

  - 스키마가 없거나 느슨한 스키로 데이터 저장

  - 데이터 질의 API 다양함

  - 유연하고 확장성이 좋음

  - 데이터를 자주 변경하지 않고 정확한 데이터 구조를 알 수 없는 경우 사용함

  - 키-값 : `Redis` , 문서형(JSON, XML) : `MongoDB`

<br><br>

## 관계형 DBMS

#### 테이블 구조

[![테이블구조](https://github.com/workhardslave/cs-study/raw/main/Database/img/dbms1.png)](https://github.com/workhardslave/cs-study/raw/main/Database/img/dbms1.png)

- 테이블 : 행(인스턴스)과 열(릴레이션 스키마)로 이루어진 데이터 집합
- 스키마 : 데이터 구조와 구성을 설명
- 행 : 한 객체에 대한 정보, `튜플` 이나 `레코드`라고 불림
- 열 : 개체의 특성,  `속성`이라고 불림.
- 도메인 : 속성 하나가 취할 수 있는 같은 타입의 원자값들의 집합

<br>

#### 뷰

- 데이터 베이스에 존재하는 일종의 가상 테이블 
- 실제 테이블처럼 행과 열을 가지고 있지만, 실제로 데이터를 저장하지 않음
- 뷰를 사용하면 여러 테이블이나 뷰를 하나의 테이블처럼 볼 수 있음
- 뷰의 장점
  - 특정 사용자에게 테이블 전체가 아닌 필요한 컬럼만 보여줄 수 있음
  - 복잡한 쿼리를 단순화해서 사용 가능
  - 쿼리 재사용 가능
- 뷰의 단점
  - 한번 정의된 뷰는 변경할 수 없음
  - 삽입, 삭제, 갱신 작업에 많은 제한 사항을 가짐
  - 자신만의 인덱스를 가질 수 없음

<br>

#### 키(Key)

[![키](https://user-images.githubusercontent.com/38900338/139516864-ce72fa77-10dc-465c-9e6d-959db391f61d.png)](https://user-images.githubusercontent.com/38900338/139516864-ce72fa77-10dc-465c-9e6d-959db391f61d.png)

- 검색, 정렬 시 튜블을 **구별하는 기준이 되는 속성**

> **👆 여기서 용어정리** 
>
> **유일성** : 키로 튜플을 유일하게 식별할 수 있음 
>
> **최소성** : 튜블을 구분하는데 꼭 필요한 속성들로만 구성

- 슈퍼키

  - 테이블에서 각 행을 유일하게 식별할 수 있는 하나 또는 그 이상의 속성들의 집합

  - `유일성`을 만족

- 후보키

  - 테이블에서 각 행을 유일하게 식별할 수 있는 최소한의 속성들의 집합
  - `유일성` 과 `최소성`을 만족
  - 모든 테이블은 하나 이상의 후보키를 가짐

- 기본키

  - 후보키들 중 하나를 선택한 키

  - 중복 값과 NULL값 불가 (`개체 무결성`)

- 대체키 (보조키) : 기본키로 선정되지 않은 후보키

- 외래키

  - 다른 테이블의 기본키를 참조하는 키
  - 외래키는 중복값을 가질 수 있고 Null 값 허용

  - 사용하는 이유 : 테이블 연결, 중복 방지, 무결성 유지

- 복합키
  - 기본키가 되지 못하는 컬럼들을 서로 묶어서 기본키처럼 사용하는 것

<br><br>

### 정규화

- 테이블 간에 중복된 데이타를 허용하지 않음으로 무결성을 유지하기

- 한 릴레이션에 여러 엔티티의 어트리뷰트들을 혼합하게 되면 데이터 `중복 저장`과 `이상현상` 문제가 발생한다.

  - 삽입 이상 : 튜플 삽입 시 특정 속성에 해당하는 값이 없어 null을 입력해야 하는 현상

  - 수정 이상 : 튜플 수정 시 중복된 데이터의 일부만 수정되어 일어나는 데이터 불일치

  - 삭제 이상 : 튜플 삭제 시 같이 저장된 다른 정보까지 연쇄적으로 삭제되는 현상

- 이러한 문제 해결을 위해 정규화 과정 진행

- 관계형 DB에서 중복을 최소화하기 위해 데이터를 구조화하는 작업

- 릴레이션의 속성들을 나눠 **좋은 작은 릴레이션으로 분해**하는 작업

  > 👆 나쁜 릴레이션이란?
  >
  > - 함수적 종속성은 좋은 릴레이션 설계의 정형적 기준
  > - 어떠한 함수적 종속성을 만족하는지에 따라 정규형이 결정
  > - 이를 만족하지 못하면 나쁜 릴레이션

  > ✌️ 함수적 종속성?
  >
  > - 어떤 속성 A의 값을 알면 다른 속성 B의 값을 유일하게 정해지는 관계
  > - A → B 라고 표기하며 A를 B의 결정자라는 의미

- 정규형이란 정규화 과정을 통해 특정 조건을 만족하는 릴레이션의 스키마 형태

<br>

#### 장단점

- 장점 : 이상 현상 제거

- JOIN 연산 증가. 릴레이션의 분해로 릴레이션 간의 JOIN 연산이 많아짐
- 질의에 대한 응답시간이 늘여질**수도** 있음.
- 조인이 많아 성능 저하가 나타나면 반정규화를 적용할 수도 있음.

<br><br>

### 정규형

각각의 정규형은 다음을 만족해야 한다.

- 하나의 릴레이션을 분해하고 다시 조인 연산을 했을 때, 데이터 손실이 없어야 함(무손실 조인)
- 함수적 종속성을 보존

#### 제 1정규형(1NF)

- 테이블 칼럼이 분해되지 않는 `원자값`을 가져야함.

<br>

#### 제 2정규형(2NF)

- 제 1정규형 만족

- 모든 칼럼이 부분적 종속이 없어져야 함. 

  = 모든 칼럼이 완전 함수 종족을 만족해야 함.

> 👆**완전 함수 종속?** 
>
> 어떤 속성이 기본키에 대해 완전히 종속일 때 
>
> 👆**부분 함수 종속?** 
>
> 어떤 속성이 기본키가 아닌 다른 속성에 종속되거나, 기본키가 여러 속성으로 구성되어 있을 때 기본키를 구성하는 속성 중 일부만 종속될 때.

<br>

#### 제 3정규형(3NF)

- 제 2정규형 만족
- 기본키를 제외한 속성들 간에 이행 종속성이 없어야 함.

> 👆**이행 종속성?**
>
> A → B , B → C 인 경우 A → C 가 성립될 때.
>
> 즉, A를 알면 B를 알고 그를 통해 C를 알 수 있는 경우를 의미

<br>

#### BCNF 정규형

- 제 3정규화를 진행한 테이블에 대해 모든 결정자가 후보키가 되도록 테이블을 분해
- 장점
  - 이상현상 문제 해결
  - 저장 공간의 최소화
  - 데이터베이스 변경 시 재구성 최소화
  - 정규화된 테이블들 간의 관계 → 현실 세계의 개념들을 반영
- 단점
  - 릴레이션이 분해될 수록 릴레인션 간의 조인 연산이 많아짐 → 성능 저하
  - 이를 해결하기 위해 반정규화 작업 수행

<br><br><br>

# 질문

#### 데이터베이스는 왜 사용하게 됐나요?



<br>

#### 그럼 데이터베이스는 어떤 특징을 갖고 설계되어야 할까요?



<br>

#### 정규화는 왜 하는 건가요?

- 정보가 중복 저장되어 저장 공간을 낭비하고 또 갱신 이상이 발생하는 것을 해결하기 위함입니다.

<br>

#### 역정규화란?

- 정규화의 반대 과정으로, 테이블에 데이터를 중복 배치하는 최적화 기법입니다.

- Join 이 많이 발생해 성능 저하가 나타나는 경우 반정규화를 수행합니다.

<br>
#### 제1 정규형도 2정규형도 3정규형도 모두 이상현상이 발생하는데 왜 하는걸까요?

- 정규화를 통해 불필요한 중복 저장을 막을 수 있기 때문입니다.

<br>

#### 데이터가 자주 변경될 때는 왜 RDBMS를 사용하는게 좋은가?

NoSQL은 데이터를 분산 저장하기 때문에 update가 생길 시 실시간으로 전파하기 어렵기 때문입니다. 

<br>

#### 언제 NoSQL을 사용하면 좋을까요?

- 대용량 데이터를 저장해야할 때

- 도메인에 필요한 자료형태가 NoSQL에 적합한 경우

  예를 들어 데이터를 모두 그래프로 사용하는 도메인인 경우, 그래프 데이터 베이스를 사용하면 그래프에 최적화된 API를 사용할 수 있습니다.

<br><br><br>

# References

- [workhardslave/cs-study/DBMS~](https://github.com/workhardslave/cs-study/blob/main/Database/DBMS%20~%20%EC%99%B8%EB%9E%98%ED%82%A4%2C%20%EC%A0%95%EA%B7%9C%ED%99%94.md)
- 