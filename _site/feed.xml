<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2023-04-11T23:50:55+09:00</updated><id>/feed.xml</id><title type="html">pino’s blog</title><subtitle>Enjoy the progress</subtitle><entry><title type="html">쿠키, 세션, JWT, 캐시</title><link href="/cs/net/2022/10/22/Net_005.html" rel="alternate" type="text/html" title="쿠키, 세션, JWT, 캐시" /><published>2022-10-22T13:52:42+09:00</published><updated>2022-10-22T13:52:42+09:00</updated><id>/cs/net/2022/10/22/Net_005</id><content type="html" xml:base="/cs/net/2022/10/22/Net_005.html"><![CDATA[<h1 id="tldr">TL;DR</h1>

<p>아래 4개는 웹의 대표적인 저장소이다. <br /></p>

<ul>
  <li>쿠키 : HTTP의 <code class="language-plaintext highlighter-rouge">비연결성(Connectionless)</code>과 <code class="language-plaintext highlighter-rouge">비상태성(Stateless)</code> 특성을 보완하기 위한 방법
    <ul>
      <li>웹 사이트에 접속할 때 <strong>서버에서 생성</strong>하여 <strong>사용자 브라우저에 정보를 담는 임시 파일</strong></li>
    </ul>
  </li>
  <li>세션 : 쿠키의 트래픽 문제와 보안 이슈를 해결하기 위해 등장
    <ul>
      <li>정보(세션 id 등)를 서버에 저장하고, 브라우저를 닫을 때 소멸</li>
    </ul>
  </li>
  <li>JWT : 인증에 필요한 정보들을 암호화시킨 토큰
    <ul>
      <li>보안 문제로 Access Token과 Refresh Token 사용</li>
      <li>성능과 사용 편의성 그리고 보안성을 적절히 타협한 방식</li>
    </ul>
  </li>
  <li>웹 캐시 : 리소스 파일의 임시 저장소
    <ul>
      <li>같은 자원을 사용할 때 일일이 불러오지 않고 캐시되어 있는 자원을 사용하여 <strong>전송량은 줄이고 속도는 높이는 방법</strong></li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h4 id="쿠키와-세션의-차이">쿠키와 세션의 차이</h4>

<ul>
  <li>
    <p><strong>저장 위치</strong></p>

    <p>쿠키는 클라이언트에 메모리 또는 파일에 저장하고, 세션은 서버 메모리에 저장된다.</p>
  </li>
  <li>
    <p><strong>보안</strong></p>

    <p>쿠키는 클라이언트 로컬에 저장되기도 하고 특히 파일로 저장되는 경우 탈취, 변조될 위험이 있어 보안이 비교적 취약하다. 반대로 세션은 정보 자체는 서버에 저장되어 있으므로 비교적 안전하다.</p>
  </li>
  <li>
    <p><strong>라이프 사이클</strong></p>

    <p>Permanent 쿠키의 경우 브라우저를 종료하더라도 저장될 수 있지만, 세션은 서버에서 지워버릴 수 있기도 하고 세션 쿠키에서 세션 아이디를 저장한 경우 브라우저 종료시 정보가 날아간다.</p>
  </li>
  <li>
    <p><strong>속도</strong></p>

    <p>쿠키 사용시 서버는 요청 헤더를 바로 참조하면 되므로 속도에 유리하지만, 세션은 받은 세션 아이디를 이용해 다시 데이터를 참조해야하므로 속도가 비교적 느릴 수 있다.</p>
  </li>
</ul>

<p><br /></p>

<h4 id="jwt를-사용하는-이유">JWT를 사용하는 이유</h4>

<ul>
  <li>
    <p>서버 인프라를 확장해야 되서 여러 개의 서버를 사용해 로드 밸런싱을 수행하는 경우 문제 발생</p>

    <p>서버1과 세션을 만든 클라이언트의 세션ID는 서버1에 저장되지만 서버2는 알지 못하기 때문</p>
  </li>
  <li>
    <p>따라서 주어진 요청을 허용하거나 거부하는데 필요한 모든 정보가 포함된 <code class="language-plaintext highlighter-rouge">토큰</code>을 사용해 서버는 검증만 하는 방식을 사용한다.</p>
  </li>
</ul>

<p><br /></p>

<h4 id="웹-캐시를-사용하는-이유">웹 캐시를 사용하는 이유</h4>

<ul>
  <li>캐싱은 기본적으로 처리 속도를 높이기 위해 사용된다.</li>
  <li>웹 캐시는 서버의 정적 컨텐츠(이미지, JS, CSS 등)를 저장해 웹 사이트 서버에 해당 컨텐츠를 매번 요청해서 받지 않음으로 사이트 응답 시간을 줄이기 위한 방법이다.</li>
</ul>

<p><br /><br /><br /></p>

<h1 id="들어가기-전에">들어가기 전에</h1>

<p>HTTP 통신은 다음과 같은 특징을 가진다.</p>

<ul>
  <li>대부분의 파일 형식 전송 가능</li>
  <li>클라이언트 - 서버 구조</li>
  <li><code class="language-plaintext highlighter-rouge">비상태성 Stateless</code> : 서버는 클라이언트의 상태를 저장하지 않는다.</li>
  <li><code class="language-plaintext highlighter-rouge">비연결성 Connectionless</code> : 연결을 유지하지 않는 것을 기본 동작으로 갖는다.</li>
</ul>

<p><br /></p>

<p>실제로는 데이터 유지가 필요한 경우가 많다. 정보를 유지하지 않으면 페이지를 이동할 때마다 로그인을 다시하거나, 상품을 선택했는데 구매 페이지에 상품 정보가 없거나 하는 일이 발생할 수 있기 때문이다.</p>

<p>이에 따라 상태값을 저장할 수 있는 수단이 필요하게 됐다. 클라이언트에 정보를 파일로 남기는 것을 <code class="language-plaintext highlighter-rouge">쿠키</code>라고 하고 서버에서 별도로 저장하는 것을 <code class="language-plaintext highlighter-rouge">세션</code>이라고 한다.</p>

<p><br /><br /></p>

<h1 id="쿠키-세션-jwt-캐시">쿠키, 세션, JWT, 캐시</h1>

<ul>
  <li>HTTP 프로토콜의 <code class="language-plaintext highlighter-rouge">비연결성(Connectionless)</code>과 <code class="language-plaintext highlighter-rouge">비상태성(Stateless)</code> 특성을 보완하기 위한 방법</li>
  <li>로그인, 접속시간, 장바구니 등 다양한 <strong>사용자 정보를 관리</strong>하여 웹사이트에서 사용자 경험을 더욱 편하게 만들어 준다.</li>
</ul>

<p><br /><br /></p>

<h2 id="쿠키">쿠키</h2>

<ul>
  <li>웹 사이트에 접속할 때 <strong>서버에서 생성</strong>하여 <strong>사용자 브라우저에 정보를 담는 임시 파일</strong>이다.</li>
  <li>
    <p>제한적이지만 브라우저와 서버 간 지속적으로 유지할 수 있는 데이터를 제공한다.</p>
  </li>
  <li>쿠키의 데이터 형태는 Key와 Value로 구성되고 String 형태로 이루어져 있다. 크기는 4KB를 넘을 수 없다.</li>
</ul>

<p><br /></p>

<blockquote>
  <p>☝️ 여기서 잠깐!</p>

  <p>웹 브라우저 쿠키의 최대는 왜 4KB 일까?</p>

  <p>encodeURIComponet() 로 인코딩한 이후의 name=value 쌍은 4KB를 넘을 수 없기 때문이다.</p>

  <p>또한 서버 도메인 하나당 저장할 수 있는 쿠키의 수는 20여개 정도로 한정되어 있다. (브라우저마다 상이)</p>
</blockquote>

<p><br /></p>

<h4 id="구성요소">구성요소</h4>

<ul>
  <li>Name : 쿠키의 이름</li>
  <li>Value : 쿠키의 저장된 값</li>
  <li>Option : 쿠키의 속성
    <ul>
      <li>Expires : 쿠키 만료일</li>
      <li>Domain : 쿠키가 사용되는 도메인</li>
      <li>Path : 쿠키를 반환할 경로</li>
      <li>Secure : 보안 연결 설정</li>
      <li>HTTPOnly : HTTPOnly 설정시 쿠키는 서버에 전송하는 용도로만 사용가능</li>
      <li>SameSite : XSRF 공격을 방어하기 위한 속성</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h4 id="목적">목적</h4>

<ul>
  <li>
    <p><strong>세션 관리(Session Management)</strong></p>

    <p>로그인, 사용자 닉네임, 접속 시간, 장바구니 등 서버가 알아야할 정보를 저장</p>
  </li>
  <li>
    <p><strong>개인화(Personalization)</strong></p>

    <p>사용자마다 다르게 그 사람에 적절한 페이지를 보여줄 수 있음</p>
  </li>
  <li>
    <p><strong>트래킹(Tracking)</strong></p>

    <p>사용자의 행동과 패턴을 분석하고 기록</p>
  </li>
</ul>

<p><br /><br /></p>

<h3 id="동작-과정">동작 과정</h3>

<p><img src="/assets/img/posts/cs/net/4-3_cookie_flow.png" alt="cookie 동작과정" /></p>

<ol>
  <li>클라이언트가 서버에 요청</li>
  <li>서버는 HTTP 응답 헤더에 <code class="language-plaintext highlighter-rouge">set-cookie 속성</code>을 추가하여 응답 →  클라이언트는 쿠키 저장</li>
  <li>클라이언트는 이후 서버에 요청할 때 전달받은 쿠키를 자동으로 요청 헤더에 추가하여 요청(브라우저가 자동으로 추가)</li>
  <li>서버에서 쿠키를 참고하여 로직 수행</li>
</ol>

<p><br /></p>

<h4 id="쿠키-사용-예시">쿠키 사용 예시</h4>

<ul>
  <li>아이디 저장, 로그인 상태 유지</li>
  <li>일주일간 다시 보지 않기</li>
  <li>쇼핑몰 장바구니 기능</li>
  <li>최근 검색한 상품을 광고에서 추천</li>
</ul>

<p><br /><br /></p>

<h3 id="쿠키의-종류">쿠키의 종류</h3>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Session 쿠키</code> : 웹 브라우저가 종료될 때 제거되는 쿠키</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Permanent 쿠키</code> : 브라우저가 종료돼도 유지되는 쿠키 (<code class="language-plaintext highlighter-rouge">Expires</code> 또는 <code class="language-plaintext highlighter-rouge">Max-Age</code> 옵션으로 쿠키가 얼마나 유지될지 정해줌)</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Secure 쿠키</code> : HTTPS 프로토콜에서만 사용, 쿠키 정보가 암호화 되어 전송됨 <strong>(쿠키 탈취문제 예방)</strong></p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Third-Party 쿠키</code> : 사용자가 방문한 웹 사이트에서 발행한 쿠키가 아니라, 다른 웹 사이트에서 발행한 쿠키</p>

    <ul>
      <li>
        <p>다른 사이트의 사용내역에 대한 정보를 쿠키로부터 가져와 활용할 수 있어 사용자의 온라인상 행동을 추적 및 데이터를 분석해 광고 등에 사용할 수 있다.</p>
      </li>
      <li>
        <p>방문한 도메인과 다른 도메인의 쿠키 보통 광고 베너 등을 관리할 때 유입 경로를 추적하기 위해 사용</p>
      </li>
      <li>
        <p><code class="language-plaintext highlighter-rouge">ads.com</code> 스크립트가 심어져 있는<code class="language-plaintext highlighter-rouge"> amazon.com</code> 에서 A 상품을 보면 <code class="language-plaintext highlighter-rouge">ads.com</code> 은 사용자가 <code class="language-plaintext highlighter-rouge">amazon.com</code>에서 A 상품을 봤다는 정보를 담아 쿠키를 발행,</p>

        <p>사용자가 <code class="language-plaintext highlighter-rouge">cupang.com</code> 사이트에 방문했을 때 <code class="language-plaintext highlighter-rouge">cupang.com</code> 에 <code class="language-plaintext highlighter-rouge">ads.com</code> 스크립트가 심어져 있다면 <code class="language-plaintext highlighter-rouge">amazon.com</code> 에서 A 상품 봤다는 것을 쿠키 정보로 광고를 보여줄 수 있다.</p>
      </li>
    </ul>

    <blockquote>
      <p>☝️ 여기서 잠깐!</p>

      <p>구글 크롬에서 2023년까지 서드파티 쿠키 지원을 중단하고 FLoC 기술로 대체한다고 발표한 바 있음. 그러나 서드파티 쿠키의 문제점을 해결한 기술이 전혀 아니라는 의견이 있음.</p>

      <p><a href="https://www.boannews.com/media/view.asp?idx=95418">- 서드파티 쿠키 대신 플록 제안한 구글, 사실은 덫을 놓았나?</a></p>
    </blockquote>
  </li>
</ul>

<p><br /><br /></p>

<h3 id="단점">단점</h3>

<ul>
  <li>
    <p>쿠키에 대한 매 정보를 헤더가 추가해서 보내기 때문에 <strong>추가적인 트래픽</strong> 발생</p>
  </li>
  <li>
    <p>불안 요소가 많고 <strong>해킹의 위험</strong>도 높다.</p>

    <p>-&gt; 따라서 조작되거나 가로채여도 큰 일은 없을 수준의 정보들을 저장</p>
  </li>
</ul>

<p><br /><br /></p>

<h3 id="보안-옵션">보안 옵션</h3>

<h4 id="secure">Secure</h4>

<ul>
  <li>HTTPS 프로토콜에서만 쿠키를 전송(쿠키 탈취문제 예방)</li>
  <li>그래도 민감한 정보는 담지 않는 것이 좋다.</li>
</ul>

<p><br /></p>

<h4 id="httponly">HttpOnly</h4>

<ul>
  <li>
    <p>Cross Site Scripting(XSS) 공격 방지</p>
  </li>
  <li>
    <p>브라우저에서 쿠키 접근 불가</p>
  </li>
  <li>
    <p>HttpOnly 속성 정의된 쿠키는 서버에 전송하는 용도로만 사용할 수 있다.</p>

    <p>-&gt; HttpOnly가 설정된 쿠키는 HTTP 통신 상에서만 사용되어아 하기 때문에, 자바스크립트 같은 외부 프로그램은 접근할 수 없다.</p>
  </li>
  <li>
    <p>그러나 최근 웹 페이지들은 SPA로 구현되어지고 AJAX를 통해 서버와 통신하는데, HttpOnly 옵션을 가진 쿠키는 JavaScript를 통해 접근하지 못해 쿠키 값을 서버에 전송할 수 없다.</p>
  </li>
</ul>

<p><br /></p>

<h4 id="samesite">SameSite</h4>

<ul>
  <li>XSRF 공격을 방어하기 위한 속성</li>
  <li>
    <p>Cross-Site 요청에 쿠키를 포함할지 포함하지 않을지 결정하는 쿠키 보안 속성</p>
  </li>
  <li><code class="language-plaintext highlighter-rouge">None</code> : SmaeSite 속성이 등장하기 전 동작하던 쿠키 방식
    <ul>
      <li>쿠키는 크로스 사이트 요청에도 항상 전송됨</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Lax</code> : 웹 페이지 이동과 안전한 HTTP 메서드 요청의 경우 쿠키를 전송
    <ul>
      <li><code class="language-plaintext highlighter-rouge">&lt;a href&gt;</code>, <code class="language-plaintext highlighter-rouge">&lt;link href&gt;</code> ,<code class="language-plaintext highlighter-rouge"> &lt;form method=get&gt;</code>에서는 쿠키 전송</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Static</code> : 모든 크로스 사이트 요청에 쿠키를 전송하지 않음</li>
</ul>

<p><br /></p>

<blockquote>
  <p>☝️여기서 잠깐!</p>

  <p>XSS (Cross Site Scripting) : 공격자가 웹 사이트에 악성 스크립트를 주입해 사용자 브라우저에서 악성 스크립트를 실행시키는 공격</p>

  <p>XSRF (Cross Site Request Forgery) : 사용자가 자신의 의지와 무관하게 공격자가 의도한 행위(수정, 삭제 등)를 특정 웹사이트에 요청하게 하는 공격</p>
</blockquote>

<p><br /><br /><br /></p>

<h2 id="세션">세션</h2>

<ul>
  <li>쿠키의 트래픽 문제와 보안 이슈를 해결하기 위해 등장</li>
  <li>사용자가 브라우저를 통해 웹 서버에 접속한 시점부터 종료하는 시점까지 일련의 요청들을 하나의 상태로 보고 그 상태를 일정하게 유지시키는 기술 <strong>(논리적인 연결)</strong></li>
  <li>정보를 서버에 저장하고, 브라우저를 닫을 때 소멸</li>
  <li>세션 ID로 클라이언트를 구분해, 클라이언트 요구에 맞는 서비스를 제공</li>
  <li>보안 면에서 쿠키보다 우수하지만 사용자가 많아질 수록 서버 메모리를 많이 차지하게 됨</li>
</ul>

<p><br /></p>

<h3 id="동작-과정-1">동작 과정</h3>

<p><img src="/assets/img/posts/cs/net/4-3_session_flow.png" alt="session 동작과정" /></p>

<ol>
  <li>클라이언트가 서버에 처음으로 요청을 보냄 (처음이라 <code class="language-plaintext highlighter-rouge">session id</code>가 존재하지 않음)</li>
  <li>서버에서 <code class="language-plaintext highlighter-rouge">session id</code>를 발급하여 응답</li>
  <li>클라이언트가 전달 받은 <code class="language-plaintext highlighter-rouge">session id</code>를 쿠키로 저장</li>
  <li>클라이언트는 매 요청마다 헤더 쿠키에 넣어 요청</li>
  <li>서버는 <code class="language-plaintext highlighter-rouge">session id</code>를 통해 사용자를 식별하고 클라이언트 상태 정보를 유지하며 응답</li>
  <li>클라이언트 종료 시 <code class="language-plaintext highlighter-rouge">session id</code> 제거, 서버에서도 제거</li>
</ol>

<p><br /></p>

<blockquote>
  <p>☝️ 여기서 잠깐!</p>

  <p>만약 클라이언트가 로그인을 성공하면 서버는 <code class="language-plaintext highlighter-rouge">새로운 session id</code>(로그인을 인증받은)를 발급한다. 클라이언트도 <code class="language-plaintext highlighter-rouge">새로 발급 받은(로그인 인증 받은) session id</code>와 함께 요청하게 된다.</p>
</blockquote>

<p><br /></p>

<h4 id="세션-사용-예시">세션 사용 예시</h4>

<ul>
  <li>
    <p>로그인 같이 보안에 필요한 작업에 사용</p>
  </li>
  <li>
    <p>한 페이지 내에서 로그인하고 다른 페이지를 왔다 갔다 할 때도 로그인 정보 유지</p>
  </li>
</ul>

<p><br /><br /></p>

<h3 id="세션의-단점">세션의 단점</h3>

<ul>
  <li>
    <p>서버에 데이터를 저장하기 때문에 양이 많아질수록 부하가 커지고 저장 공간 부족 문제 발생</p>

    <p>-&gt; 동시접속자 수가 많은 웹 사이트의 경우 서버에 과부화를 주게 되어 성능 저하의 요인이 됨</p>
  </li>
  <li>
    <p>쿠키에 정보가 있으면 헤더를 바로 참조하면 되지만, 세션은 세션 아이디를 이용해 서버에서 데이터를 참조해야 하므로 속도가 비교적 느릴 수 있다.</p>
  </li>
  <li>
    <p>session id 또한 탈취되면 보안 상 문제 발생</p>
  </li>
</ul>

<p><br /></p>

<h4 id="해결-방법">해결 방법</h4>

<ul>
  <li>HTTPS 사용해 서버와 클라이언트 간의 주고받는 정보를 암호화해 요청을 탈취하더라도 읽지 못하게 하기</li>
  <li>세션에 유효시간을 지정하기 (일정 시간 지나면 해당 클라이언트와 서버의 세션 끊기)</li>
</ul>

<p><br /><br /><br /></p>

<h2 id="jwt-json-web-token">JWT (JSON Web Token)</h2>

<ul>
  <li>인증에 필요한 정보들을 암호화시킨 토큰</li>
  <li><code class="language-plaintext highlighter-rouge">Token</code> : 인증을 위해 사용되는 암호화된 문자열</li>
  <li>서버는 토큰이 유효한지만 확인하면 되고 별도의 저장소가 필요없어 세션 인증에 비해 <strong>서버 운영의 효율이 더 좋다.</strong></li>
  <li>토큰 기반으로 하는 다른 인증 시스템(구글, 페이스북 로그인)에 접근이 가능해 확장성이 뛰어나다.</li>
  <li>C, Python, Java, JavaScript 등 대부분의 프로그래밍 언어에서 지원되어 범용성이 좋다.</li>
</ul>

<p><br /></p>

<h4 id="구성요소-1">구성요소</h4>

<ul>
  <li>
    <p><strong>Header(헤더)</strong></p>

    <p>토큰의 타입과 해싱할 알고리즘 방식(일종의 metadata 정보)</p>
  </li>
  <li>
    <p><strong>Payload(정보)</strong></p>

    <p>토큰에 담을 정보 (일반적으로 유저의 고유 ID값과 유효기간)</p>
  </li>
  <li>
    <p><strong>Verify Signature(서명)</strong></p>

    <ul>
      <li>Base64 방식으로 인코딩한 <code class="language-plaintext highlighter-rouge">Header</code>  <code class="language-plaintext highlighter-rouge">Payload</code>  <code class="language-plaintext highlighter-rouge">SECRET KEY</code> 를 더한 후 서명</li>
    </ul>

    <p><br /></p>

    <blockquote>
      <p>☝️ 여기서 잠깐!</p>

      <p>Verify Signature를 사용하는 이유는?</p>

      <p>Verify Signature는 <code class="language-plaintext highlighter-rouge">SECRET KEY</code>를 알지 못하면 복호화 할 수 없다.</p>

      <p>만약 누군가가 A의 토큰을 조작해 데이터를 훔치려고 할 때, A 토큰의 ID를 자신의 ID로 바꿔서 서버에 보내야 한다. 그런데 이때 서버는 암호화된 Verify Signature를 검사해서 정보가 바뀐 토큰을 유효하지 않은 토큰으로 간주하게 된다.</p>

      <p>즉, SECRET KEY를 알지 못하는 이상 토큰을 조작할 수 없다는 것이다.</p>
    </blockquote>
  </li>
</ul>

<p><br /><br /></p>

<h3 id="토큰-전달과-저장-방법">토큰 전달과 저장 방법</h3>

<p><img src="/assets/img/posts/cs/net/4-3_jwt_flow.png" alt="JWT 동작 과정" /></p>

<h4 id="로그인-시">로그인 시</h4>

<ol>
  <li>
    <p>브라우저에서 사용자가 로그인하면 서버에 이메일과 비밀번호를 전송</p>
  </li>
  <li>
    <p>서버에서 이메일과 비밀번호를 확인 후 사용자가 확인되면<code class="language-plaintext highlighter-rouge"> JWT</code>를 생성</p>

    <p>(사용자 고유 ID값을 부여하고, 기타 정보와 함께 Payload에 넣음)</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">JWT</code>의 유효기간을 설정하고, <code class="language-plaintext highlighter-rouge">SECRET KEY</code> 이용해 Access Token 발급</p>
  </li>
  <li>
    <p>사용자는 Access Token을 받아 쿠키에 저장</p>
  </li>
  <li>
    <p>인증이 필요한 요청마다 토큰을 헤더에 실어 보냄</p>
  </li>
  <li>
    <p>서버에서 해당 토큰의 Signature를 <code class="language-plaintext highlighter-rouge">SECRET KEY</code>로 복호화한 후, 조작 여부와 유효 기간을 확인</p>
  </li>
  <li>
    <p>해당 토큰 검증이 완료되면 Payload를 디코딩하고 해석한 정보에 따라 응답</p>
  </li>
</ol>

<p><br /><br /></p>

<h3 id="단점-1">단점</h3>

<ul>
  <li>
    <p>이미 발급된 JWT에 대해서는 돌이킬 수 없다.</p>

    <p>세션/쿠키의 경우 쿠키가 악의적으로 이용되면 해당 세션을 지워버리면 된다. 하지만 JWT는 한 번 발급되면 유효기간이 완료될 때까지 계속 사용이 가능하다.</p>
  </li>
  <li>
    <p>Payload 정보가 제한적이다.</p>

    <p>Payload는 따로 암호화되지 않아 디코딩하면 누구나 정보를 확인할 수 있기 때문에, 중요한 정보는 넣을 수 없다.</p>
  </li>
  <li>
    <p>JWT 길이가 쿠키와 세션에 비해 길다.</p>

    <p>인증에 필요한 요청이 많아질 수록 서버 자원 낭비가 발생한다.</p>
  </li>
</ul>

<p><br /></p>

<h3 id="해결-방법---refresh-token">해결 방법 - Refresh Token</h3>

<ul>
  <li>JWT(Access Token)의 경우 보안을 위해 유효 기간을 짧게 세팅한다. 그러나 이러면 사용자가 새 토큰을 발급받기 위해 로그인을 자주 시도해야 한다.</li>
  <li>처음 인증을 완료했을 때 유효기간이 짧은 Access Token과 유효기간이 긴(보통 2주) Refresh Token을 동시에 발급하고, Access Token이 만료되면 Refresh Token을 통해 새로 토큰을 발급 받는다.</li>
  <li>여전히 Access Token을 탈취 당하면 정보가 유출되는건 동일하지만, 유효기간이 짧아 조금 더 안전하게 하자는 의미 + 서버는 Refresh Token을 삭제함으로 강제 로그아웃 시킬 수 있음</li>
  <li>하지만 검증 프로세스가 길어져 구현이 복잡하고, Access Token 만료될 때 마다 새로 발급하는 과정에서 HTTP 요청 횟수가 많아 서버 자원 낭비로 이어질 수 있다.</li>
</ul>

<p><img src="/assets/img/posts/cs/net/4-3_refresh_token_flow.png" alt="" /></p>

<ol>
  <li>
    <p>시간이 흘러 <code class="language-plaintext highlighter-rouge">Access Token</code>이 만료</p>
  </li>
  <li>
    <p>사용자는 만료된 <code class="language-plaintext highlighter-rouge">Access Token</code>을 헤더에 실어 요청을 보낸다.</p>
  </li>
  <li>
    <p>서버는 <code class="language-plaintext highlighter-rouge">Access Token</code>이 만료됨을 확인</p>
  </li>
  <li>
    <p>만료된 토큰임을 알리고 권한없음을 신호로 보낸다.</p>

    <blockquote>
      <p>☝️ 여기서 잠깐!</p>

      <p>Access Token이 만료될때 마다 9~11 과정을 거칠 필요는 없다.</p>

      <p>Access Token의  Payload를 통해 유효기간을 알수 있다.</p>

      <p>따라서 프론트엔드 단에서 API 요청 전에 토큰이 만료 됐다면 바로 재발급 요청 가능.</p>
    </blockquote>
  </li>
  <li>
    <p>사용자는 <code class="language-plaintext highlighter-rouge">Refresh Token</code>과 <code class="language-plaintext highlighter-rouge">Access Token</code>을 함께 서버로 보낸다.</p>
  </li>
  <li>
    <p>서버는 받은 <code class="language-plaintext highlighter-rouge">Access Token</code>이 조작되지 않았는지 확인한후, <code class="language-plaintext highlighter-rouge">Refresh Token</code>과 사용자의 DB에 저장되어 있던 <code class="language-plaintext highlighter-rouge">Refresh Token</code>을 비교한다.</p>
  </li>
  <li>
    <p>서버는 Token이 동일하고 유효기간도 지나지 않았다면 <code class="language-plaintext highlighter-rouge">새로운 Access Token</code>을 사용자에게 보내준다.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">새로운 Access Token</code>을 헤더에 실어 API 요청</p>
  </li>
</ol>

<p><br /></p>

<h4 id="사용-예시">사용 예시</h4>

<ul>
  <li>일정 시간이 지나면 자동으로 로그아웃되는 기능</li>
  <li>최초 로그인한 ip와 다른 ip에서 로그인 요청이 왔을 때 강제 로그아웃 기능 (Refresh 삭제하기)</li>
</ul>

<p><br /><br /><br /></p>

<h2 id="캐시">캐시</h2>

<ul>
  <li>
    <p>리소스 파일들의 임시 저장소</p>

    <p>(자주 사용되는 이미지나 html, css, js 파일 등을 브라우저에 저장해놓고 사용)</p>
  </li>
  <li>
    <p>같은 자원을 사용할 때 일일이 불러오지 않고 캐시되어 있는 자원을 사용하여 <strong>전송량은 줄이고 속도는 높이는 방법</strong></p>
  </li>
  <li>
    <p>캐시에 있는 것을 재사용하기 때문에 경우에 따라 <strong>변경된 자원을 참조할 수 없는 경우가 생김</strong></p>

    <p>-&gt; 사용자가 브라우저 캐시를 지워주거나, 서버에서 클라이언트로 응답 보낼 때 헤더에 자원 캐시 만료기간을 명시하는 방법 등을 이용해 회피할 수 있다.</p>
  </li>
  <li>
    <p>사용자가 수동으로 삭제해줘야 한다.</p>
  </li>
</ul>

<p><br /></p>

<h4 id="content-delivery-network-cdn">Content Delivery Network (CDN)</h4>

<ul>
  <li>지리적으로 분산된 여러 개의 서버를 이용해 웹 콘텐츠를 사용자와 가까운 서버에 전송함으로 전송 속도를 높이는 방법</li>
  <li>각 지역에 캐시 서버(PoP, Points of presence)를 분산 배치해 근접 사용자의 요청에 본 서버가 아닌 캐시 서버가 콘텐츠를 전달한다.</li>
  <li>서버와 사용자의 물리적 거리를 줄여 콘텐츠 로딩에 소요되는 시간을 최소화한다.</li>
  <li>치킨 체인점이 전국 주문을 본사에서 전부 처리하지 않고 각지의 체인점에서 받는 것처럼, CDN은 여러 지역에 설치된 캐시 서버를 사용해 본 서버로 들어오는 요청을 분산 처리하는 서비스다.</li>
</ul>

<p><br /><br /><br /></p>

<h1 id="추가-내용">추가 내용</h1>

<h3 id="브라우저-저장소">브라우저 저장소</h3>

<p>브라우저에서 지원하는 저장소는 쿠키 외에도 <code class="language-plaintext highlighter-rouge">로컬 스토리지(Local Storage)</code>와 <code class="language-plaintext highlighter-rouge">세션 스토리지(Session Storage)</code>가 있다.</p>

<ul>
  <li>HTML5에 추가된 key-value 스토리지로, 클라이언트에 대한 정보를 로컬에 저장.</li>
  <li>로컬 스토리지 : 유효 기간이 없고 영구적으로 이용 가능</li>
  <li>세션 스토리지 : 세션 종료 시(브라우저 닫을 시) 데이터가 삭제됨</li>
</ul>

<p><br /></p>

<h4 id="장점">장점</h4>

<ul>
  <li>5MB까지 사용 가능</li>
  <li>쿠키와 다르게 웹 스토리지는 네트워크 요청 시 서버로 전송되지 않아 쿠키보다 더 많은 자료를 보관할 수 있다.</li>
</ul>

<p><br /></p>

<h4 id="단점-2">단점</h4>

<ul>
  <li>HTTP5 지원하지 않는 브라우저는 사용 불가</li>
  <li>XSS(Cross Site Scripting)공격에 취약, 그러나 CSRF 공격엔 더 안전</li>
</ul>

<p><br /><br /></p>

<h3 id="xsrf-cross-site-request-forgery-공격">XSRF (Cross Site Request Forgery) 공격</h3>

<ul>
  <li>사용자가 자신의 의지와 무관하게 공격자가 의도한 행위(수정, 삭제 등)를 특정 웹사이트에 요청하게 하는 공격</li>
  <li>특정 웹 사이트가 사용자의 웹 브라우저를 신뢰하는 상태를 노린 공격</li>
  <li>사용자가 웹 사이트에 로그인한 상태에서 XSRF 공격 코드가 삽입된 페이지를 열면, 공격 대상이 되는 웹사이트는 위조된 공격 명령이 믿을 수 있는 사용자로부터 발송된 것으로 판단하게 되어 공격에 노출된다.</li>
  <li>예를 들어, 페이스북에 희생자의 계정으로 광고성 글을 올리거나, 희생자가 피싱 사이트에 접속하도록 하는 것</li>
</ul>

<p><br /></p>

<h4 id="대응-방법">대응 방법</h4>

<ul>
  <li>피싱 페이지에서 호출한 백엔드 API가 실패되도록 해야 한다.</li>
  <li>백엔드 API가 정상적으로 응답해야 하는지 판단해야 하기 때문에 백엔드 측에서 대응해줘야 한다.</li>
</ul>

<ol>
  <li>쿠키의 SameSite 사용
    <ul>
      <li>SameSite 속성 값으로 <code class="language-plaintext highlighter-rouge">Lax</code>, <code class="language-plaintext highlighter-rouge">Strict</code> 사용하면 쿠키를 동일한 사이트에서만 전달 할 수 있게 할 수 있다.</li>
      <li>구형 브라우저에서는 SameSite 속성을 지원하지 않아 한계가 있다.</li>
    </ul>
  </li>
  <li>Referer 체크
    <ul>
      <li>Request 헤더의 Referer을 확인해 유효한 사이트에서 API를 호출하는지 확인하는 방법</li>
      <li>Same-Origin Policy(SOP)를 지키면 XSRF 공격을 방어할 수 있지만, 다른 출처의 자원을 사용해야 하는 경우가 있어 CORS를 허용해주는 경우가 많다.</li>
      <li>이 경우 CORS를 위해 모든 출처를 허용하지 않고 유효한 출처만 허용하는 것이 좋다.</li>
    </ul>
  </li>
  <li>Security Token 사용
    <ul>
      <li>사용자 인증 절차를 좀 더 복잡하게 만들어 XSRF 공격 막기</li>
      <li>임의의 토큰을 발급해 서버의 세션에 토큰을 저장하고, 그 토큰을 프론트 엔드로 전달</li>
      <li>프론트엔드에서는 API를 호출할 대 전달 받은 토큰을 함께 전달하고, 서버에서 세션에 저장된 토큰과 프론트엔드에서 전달 받은 토큰을 비교해 동일할 경우 API를 실행하는 방식</li>
    </ul>
  </li>
</ol>

<p><br /><br /></p>

<h3 id="xss-cross-site-scripting-공격">XSS (Cross Site Scripting) 공격</h3>

<ul>
  <li>공격자가 웹 사이트에 악성 스크립트를 주입해 사용자 브라우저에서 악성 스크립트를 실행시키는 공격</li>
  <li>웹 사이트 관리자가 아닌 다른 사람이 웹 페이지에 악성 스크립트를 삽입할 수 있는 점을 노린 공격</li>
</ul>

<p><br /></p>

<h4 id="비-지속적non-persistent-공격-방법">비 지속적(Non-persistent) 공격 방법</h4>

<ul>
  <li>
    <p>Reflected XSS</p>
  </li>
  <li>포탈 사이트에서 문자열을 검색할 때, 일반적으로 검색 결과 페이지에서 검색한 문자열을 그대로 다시 표시한다.</li>
  <li>검색한 문자열에 스크립트가 포함되어 그 스크립트가 실행된다면 비 지속적 XSS 공격에 취약점을 가지고 있는 것이다.</li>
</ul>

<p><br /></p>

<h4 id="지속적persistent-공격-방법">지속적(Persistent) 공격 방법</h4>

<ul>
  <li>비 지속적 공격 방법보다 치명적인 공격 방법</li>
  <li>공격자가 게시판에 글쓰기를 통해 스크립트를 포함한 게시글을 작성한 후 서버에 저장,</li>
  <li>다른 사용자가 게시글 읽을 때 게시글에 포함된 스크립트가 실행되면서 XSS 공격이 성공하게 됨</li>
  <li>게시글을 읽는 사용자의 개인정보를 공격자에게 전송시키는 스크립트가 포함되어 있다고 한다면, 게시글을 읽는 모든 사람의 개인 정보가 유출되는 것이다.</li>
  <li>사용자의 정보(쿠키, 세션 등)를 탈취하거나 비정상적인 기능(게시글 삭제, 수정 등)을 수행하게 할 수 있다.</li>
</ul>

<p><br /></p>

<h4 id="대응-방법-1">대응 방법</h4>

<ul>
  <li>XSS 공격은 보통 프론트 엔드 측에서 대응해준다.</li>
  <li>페이지에서 공격자가 입력한 스크립트를 실행하지 못하게 해야 한다.
    <ol>
      <li>스크립트 입력을 막거나,
        <ul>
          <li>스크립트를 입력하지 못하도록 막는다. (<code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> 태그 방지)</li>
          <li>그러나 다른 방식(이벤트 핸들러 등)로도 스크립트를 실행할 수 있어 모든 케이스에 대응해 입력 값을 제한하는 것은 쉽지 않다.</li>
        </ul>
      </li>
      <li>브라우저가 스크립트를 실행하지 못하도록 스크립트 값을 변경해야 한다.
        <ul>
          <li>HTML 태그에 사용되는 <code class="language-plaintext highlighter-rouge">&lt;</code> <code class="language-plaintext highlighter-rouge">&gt;</code> 문자열을 인코딩한 것을 저장해 브라우저가 일반 문자열로 인식해 스크립트가 실행되지 않도록 하는 방법</li>
        </ul>
      </li>
    </ol>
  </li>
</ul>

<p><br /><br /><br /></p>

<h1 id="예상-질문--모의-면접-질문">예상 질문 + 모의 면접 질문</h1>

<h3 id="http-프로토콜의-비상태성-비연결성의-장점이-뭐라고-생각하시나요">HTTP 프로토콜의 비상태성, 비연결성의 장점이 뭐라고 생각하시나요?</h3>

<p>계속해서 통신 연결을 유지하지 않기 때문에 리소스 낭비가 줄어듭니다.</p>

<p><br /></p>

<h4 id="http를-사용할-때-서버는-클라이언트의-정보를-저장하지-않는데-어떻게-자동-로그인이나-장바구니-기능을-사용할-수-있을까요">HTTP를 사용할 때 서버는 클라이언트의 정보를 저장하지 않는데, 어떻게 자동 로그인이나 장바구니 기능을 사용할 수 있을까요?</h4>

<p>쿠키나 세션을 이용해서 상태값을 클라이언트나 서버에 저장함으로 로그인과 장바구니 기능을 사용할 수 있습니다.</p>

<p><br /><br /></p>

<h3 id="쿠키와-세션의-차이점과-쿠키와-세션-각각의-특징을-설명해주세요"><strong>쿠키와 세션의 차이점과 쿠키와 세션 각각의 특징을 설명해주세요</strong></h3>

<p>가장 큰 차이는 정보가 저장되는 위치입니다. 쿠키는 클라이언트, 세션은 서버의 자원을 사용합니다.</p>

<p>쿠키는 요청 속도가 빠르고 세션은 쿠키보다 더 보안이 좋다는 점이 특징입니다.</p>

<p><br /><br /></p>

<h3 id="인터넷-쇼핑을-할-때-쿠팡에서-시리얼을-보고-나면-sns에서도-시리얼-광고가-나오는데-이건-어떻게-가능한-일일까요">인터넷 쇼핑을 할 때, 쿠팡에서 시리얼을 보고 나면 SNS에서도 시리얼 광고가 나오는데 이건 어떻게 가능한 일일까요?</h3>

<p>서드파티 쿠키를 사용하기 때문에 가능합니다. 서드파티 쿠키란 사용자가 방문한 웹 사이트에서 발행한 쿠키가 아니라, 다른 웹 사이트에서 발행한 쿠키인데, 다른 사이트의 사용내역에 대한 정보를 쿠키로부터 가져와 활용할 수 있어 사용자의 온라인상 행동을 추적 및 데이터를 분석해 광고 등에 사용할 수 있습니다.</p>

<p><br /></p>

<h4 id="서드파티-쿠키의-단점은-무엇인가요">서드파티 쿠키의 단점은 무엇인가요?</h4>

<p>서드파티 쿠키를 추적함으로 개인정보보호를 침해할 수 있습니다.</p>

<p><br /><br /></p>

<h3 id="jwt는-무엇이고-장단점에-대해-설명해주세요">JWT는 무엇이고 장단점에 대해 설명해주세요.</h3>

<p>Json Web Token의 약자로 모바일이나 웹의 사용자 인증을 위해 사용하는 암호화된 토큰입니다.</p>

<p>보안성 쿠키를 전달하지 않아도 되어 취약점이 사라지지만 JWT 토큰이 길어질 수록 오버헤드가 심해진다는 단점이 있습니다.</p>

<p><br /><br /></p>

<h3 id="쿠키를-사용하게-될-때-예상되는-보안-문제가-있나요">쿠키를 사용하게 될 때 예상되는 보안 문제가 있나요?</h3>

<p>쿠키는 클라이언트 로컬에 저장되기도 하고 특히 파일로 저장되는 경우 탈취, 변조될 위험이 있어 보안이 비교적 취약합니다. 공용 PC에서 쿠키값이 유출될 수 있고, XSS (Cross Site Scripting)나 XSRF (Cross Site Request Forgery) 같은 공격에 취약합니다.</p>

<p><br /></p>

<h4 id="xss-와-xsrf란">XSS 와 XSRF란?</h4>

<ul>
  <li>
    <p>XSS (Cross Site Scripting)은 공격자가 웹 사이트에 악성 스크립트를 주입해 사용자 브라우저에서 악성 스크립트를 실행시키는 공격이고,</p>
  </li>
  <li>
    <p>XSRF (Cross Site Request Forgery)는 사용자가 자신의 의지와 무관하게 공격자가 의도한 행위(수정, 삭제 등)를 특정 웹사이트에 요청하게 하는 공격입니다.</p>
  </li>
</ul>

<p><br /></p>

<h4 id="해당-문제에-대한-해결책은">해당 문제에 대한 해결책은?</h4>

<p>기본적으로 사용자가 쿠키를 잘 관리해야 하고, 쿠키 내에는 웹 공격에 대응하기 위해 XSS를 대비한 HttpOnly 옵션과 XSRF를 대비한 Samesite 옵션이 있습니다.</p>

<p>HttpOnly 옵션은 쿠키를 서버에 전송하는 용도로만 사용할 수 있도록 지정함으로써 자바스크립트 같은 외부 프로그램이 접근할 수 없도록 막는 것이고, SameSite 옵션은 Cross-Site 요청이 들어올 때 쿠키를 포함하지 않도록 막는 방법입니다.</p>

<p><br /></p>

<h4 id="많은-단점에도-굳이-쿠키를-사용하는-이유는">많은 단점에도 굳이 쿠키를 사용하는 이유는?</h4>

<p>세션은 서버에 데이터를 저장, 즉 서버의 자원을 사용하기 때문에 서버 자원에 한계가 있고 메모리를 사용하다 보면 속도 저하도 올 수 있기 때문입니다.</p>

<p>특히 쿠키는 Load Balancing이 필요할 때 큰 역할을 할 수 있습니다.</p>

<p><br /><br /></p>

<h3 id="세션-인증-방식과-토큰-인증-방식jwt의-차이점은">세션 인증 방식과 토큰 인증 방식(JWT)의 차이점은?</h3>

<p>세션 인증에서는 서버가 세션 ID를 저장하고 클라이언트가 쿠키에 실어보낸 세션 ID와 대조해서 확인하는 반면, 토큰을 사용하면 요청을 받은 서버는 토큰이 유효한지를 확인만 하기때문에 세션 인증에 비해 서버 운영의 효율이 더 좋습니다.</p>

<p><br /><br /></p>

<h3 id="refresh-token을-프론트-서버의-세션과-백엔드-서버-중-어디에-저장해야-될까요">Refresh Token을 프론트 서버의 세션과 백엔드 서버 중 어디에 저장해야 될까요?</h3>

<h5 id="1-프론트-서버의-세션에-저장하는-경우">1) 프론트 서버의 세션에 저장하는 경우</h5>

<p>Refresh token을 프론트 서버의 세션에 저장하면 클라이언트가 토큰이 저장된 세션에 접근하기 위해 Session ID를 쿠키로 가지고 있어야 합니다.</p>

<p>이 경우 새로 고침 상황에서  access token을 얻기 위해 벡엔드 서버로 요청을 보낼 필요가 없어 경제적입니다. 하지만 사용자가 많아질 수록 세션 관리가 힘들어질 수 있다는 단점이 있습니다.</p>

<p><br /></p>

<h5 id="2-백엔드-서버에-저장하는-경우">2) 백엔드 서버에 저장하는 경우</h5>

<p>Refresh token을 벡엔드 서버에 저장하면 새로 고침했을 때 Access token을 얻기위해 백엔드 서버를 거쳐야 해서 비용이 더 들게 됩니다. 하지만 사용자가 많아짐에 따라 생기는 서버 이슈가 프론트, 벡엔드로 나뉘지 않고 백엔드에서 대부분 처리하기 때문에 관리에 용이하다는 장점이 있습니다.</p>

<p><br /><br /></p>

<h3 id="refresh-token을-사용한다고-가정하고-네이버-블로그의-access-token의-유효기간이-1시간이면-글을-작성하다-1시간이-지나서-글을-발행할-때-오류가-발생할텐데-이-문제는-어떻게-해결할-수-있을까요">Refresh Token을 사용한다고 가정하고, 네이버 블로그의 Access token의 유효기간이 1시간이면 글을 작성하다 1시간이 지나서 글을 발행할 때 오류가 발생할텐데 이 문제는 어떻게 해결할 수 있을까요?</h3>

<p>일정 시간마다 새로운 Access Token을 발급 받는 설정을 추가할 수 있습니다. Access Token의 만료 기간이 1시간이라면 55분 정도에 새로운 token을 발급 받도록 해서 사용자가 Access token이 만료되었다는 사실을 모르게 연장시킬 수 있습니다.</p>

<p><br /><br /></p>

<h3 id="만약-refresh-token이-탈취-당해-해커가-refresh-token을-이용해-새로운-access-token을-요청할-수-있지-않나요-보안에-취약한-것-아닌가요">만약 Refresh Token이 탈취 당해 해커가 Refresh Token을 이용해 새로운 Access Token을 요청할 수 있지 않나요? 보안에 취약한 것 아닌가요?</h3>

<p>Refresh Token은 클라이언트와 서버 두 곳에 저장됩니다. 만약 Refresh Token이 탈취되어 해커가 새로운 Access Token을 발급한다면 서버는 다른 나라의 IP주소로 요청이 들어왔다거나 하는 검증 작업을 통해 요청을 거절하고 Refresh Token을 서버에서 지워버려 Access Token을 해커에게 발급하지 않을 수 있습니다. 즉, Refresh Token은 서버가 해킹된 토큰에 대한 방어 행동을 취할 수 있게 해주는 도구가 됩니다.</p>

<p>그리고 Access token과 Refresh Token은 보안성뿐 아니라 성능과 사용 편의성 등을 적절하게 타협한 결과입니다. 보안만 추구한다면 더 좋은 방법들이 있을 것입니다.</p>

<p><br /><br /></p>

<h3 id="secure-쿠키가-어떻게-암호화되는지-설명해주세요">Secure 쿠키가 어떻게 암호화되는지 설명해주세요.</h3>

<p>통신 과정에서 정보 유출을 막기 위해 HTTPS 프로토콜을 사용해 데이터를 암호화해 서버에 넘겨줍니다.</p>

<p>암호화는 SSL/TLS 프로토콜에서 진행합니다.</p>

<p><br /><br /></p>

<h3 id="웹-브라우저-쿠키의-최대는-왜-4kb인가">웹 브라우저 쿠키의 최대는 왜 4KB인가?</h3>

<ul>
  <li>쿠키는 <code class="language-plaintext highlighter-rouge">encodeURIComponet()</code> 메소드로 인코딩을 하는데 이때 name=value 쌍이 4KB를 넘을 수 없기 때문입니다.</li>
  <li><code class="language-plaintext highlighter-rouge">encodeURIComponet()</code> 메소드는 자바스크립트 메서드로 문자열을 URI 구성요소로서 인코딩하는 함수</li>
</ul>

<p><br /><br /><br /></p>

<h1 id="references">References</h1>

<ul>
  <li><a href="https://kotlinworld.com/97">HTTP의 특징</a></li>
  <li><a href="https://github.com/workhardslave/cs-study/blob/main/Network/Cookie_Session_JWT_Cache.md">쿠키, 세션, JWT, 캐시</a></li>
  <li>
    <p><a href="https://wildeveloperetrain.tistory.com/146">Javascript Cookie 쿠키 저장, 가져오기, 삭제 함수</a></p>
  </li>
  <li>
    <p><a href="https://nesoy.github.io/articles/2017-03/Session-Cookie">쿠키, 세션 그림</a></p>
  </li>
  <li><a href="https://beomy.github.io/tech/browser/cookie/">쿠키 보안 속성</a></li>
  <li>
    <p><a href="https://racoonlotty.tistory.com/entry/%EC%BF%A0%ED%82%A4%EC%99%80-%EC%84%B8%EC%85%98-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EB%A1%9C%EC%BB%AC-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80%EC%99%80-%EC%84%B8%EC%85%98-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80">쿠키, 세션, 로컬 스토리지와 세션 스토리지</a></p>
  </li>
  <li><a href="https://itstory1592.tistory.com/62">쿠키와 세션 로그인 처리</a></li>
  <li><a href="https://jeong-pro.tistory.com/80">쿠키, 세션, 캐시의 차이점</a></li>
  <li>
    <p><a href="https://beomy.github.io/tech/etc/xss-xsrf/">XSS, XSRF</a></p>
  </li>
  <li>
    <p><a href="https://blog.rs-team.com/12">서드파티 쿠키</a></p>
  </li>
  <li>
    <p><a href="https://velog.io/@kingth/%EC%84%9C%EB%B2%84-%EC%9D%B8%EC%A6%9D-%EB%B0%A9%EC%8B%9D%EC%84%B8%EC%85%98%EC%BF%A0%ED%82%A4-%ED%86%A0%ED%81%B0">서버 인증 방식(세션/쿠키, 토큰)</a></p>
  </li>
  <li>
    <p><a href="https://tecoble.techcourse.co.kr/post/2021-10-20-refresh-token/">Refresh Token</a></p>
  </li>
  <li>
    <p><a href="https://okky.kr/articles/1007579">Refresh Token이 필요한 이유는? 보안 관점</a></p>
  </li>
  <li><a href="https://velog.io/@tlatldms/%EC%84%9C%EB%B2%84%EA%B0%9C%EB%B0%9C%EC%BA%A0%ED%94%84-Refresh-JWT-%EA%B5%AC%ED%98%84#%EB%A1%9C%EA%B7%B8%EC%95%84%EC%9B%83-%EC%A0%95%EC%B1%85">서버 구현 시리즈</a></li>
</ul>]]></content><author><name>pino</name></author><category term="[&quot;CS&quot;, &quot;Net&quot;]" /><summary type="html"><![CDATA[TL;DR]]></summary></entry><entry><title type="html">NoSQL, 클러스터링 vs 리플리케이션, DB샤딩</title><link href="/cs/db/2022/10/21/DB_003.html" rel="alternate" type="text/html" title="NoSQL, 클러스터링 vs 리플리케이션, DB샤딩" /><published>2022-10-21T23:52:42+09:00</published><updated>2022-10-21T23:52:42+09:00</updated><id>/cs/db/2022/10/21/DB_003</id><content type="html" xml:base="/cs/db/2022/10/21/DB_003.html"><![CDATA[<h1 id="tldr">TL;DR</h1>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">데이터 베이스 (Database, DB)</code></strong>란 ? 데이터의 저장소</li>
  <li><strong><code class="language-plaintext highlighter-rouge">데이터 베이스 관리 시스템(DBMS)</code></strong>이란? 데이터 베이스를 운영하고 관리하는 소프트웨어</li>
  <li><strong><code class="language-plaintext highlighter-rouge">SQL</code></strong> 이란? 구조화된 질의 언어라는 뜻으로 관계형 데이터 베이스에서 사용되는 언어</li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">NoSQL</code></strong> 이란?</p>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">클러스터링</code></strong> vs <strong><code class="language-plaintext highlighter-rouge">리플리케이션</code></strong> : DB를 수평적, 수직적으로 확장하는 두 가지 방법</li>
  <li><strong><code class="language-plaintext highlighter-rouge">DB샤딩</code></strong> : DB 트래픽을 분산할 목적으로 데이터를 분산해서 저장하는 기법</li>
</ul>

<p><br /><br /><br /></p>

<h1 id="들어가기-전에">들어가기 전에</h1>

<h4 id="데이터-베이스를-사용하는-이유">데이터 베이스를 사용하는 이유</h4>

<p>데이터 베이스 이전에는 파일 시스템을 이용해 데이터를 관리했다. 이때 어플리케이션과 상호 연동이 되어야할 때 <code class="language-plaintext highlighter-rouge">종속성</code> 문제나 <code class="language-plaintext highlighter-rouge">데이터 무결성</code> 문제가 발생해 파일 시스템으로는 관리하기 한계가 있었다.</p>

<p>데이터 베이스는 이런 데이터 관련 문제를 해결해주는, 조직화된 데이터의 모음을 의미한다.</p>

<blockquote>
  <p>☝️ 여기서 잠깐!</p>

  <ul>
    <li>
      <p>데이터의 종속성 (Dependency) : 프로그램의 구조가 데이터의 구조에 영향을 받는 것으로, 데이터의 구조가 변경되면 프로그램까지 같이 바뀌어야 하므로 프로그램 개발과 유지보수가 어렵다.</p>
    </li>
    <li>
      <p>데이터의 중복성 (Redundancy) : 파일 시스템은 프로그램마다 데이터 공유가 안되는 경우가 많아서 같은 정보를 중복해서 저장하는 경우도 많다. 저장 공간의 낭비이기도 하지만, 데이터 관리 측면에서 같은 정보를 여러 공간에 보관하면 수정 시 모든 데이터를 수정해야 한다는 문제가 발생한다.</p>
    </li>
    <li>
      <p>데이터의 무결성 (Integrity) : 데이터의 내용이 본래의 의도와 다른 형식을 갖게될 때 무결성이 침해됐다고 말한다. 데이터가 여러 경로를 통해 들어오기 때문에 잘못된 데이터가 들어오는 경우를 의미한다.</p>
    </li>
  </ul>
</blockquote>

<p><br /><br /></p>

<h4 id="데이터-베이스-관리-시스템dbms이란">데이터 베이스 관리 시스템(DBMS)이란?</h4>

<ul>
  <li>데이터 베이스를 관리하고 운영하는 소프트웨어</li>
  <li>다수의 컴퓨터 사용자들이 컴퓨터에 수록 된 수 많은 자료들을 쉽고 빠르게 추가, 수정, 삭제 할 수 있도록 해주는 시스템</li>
  <li>데이터베이스 내의 정보를 검색하거나 정보를 저장하기 편리하고 효율적인 환경을 제공하는 것이 목적</li>
  <li>DBMS의 종류
    <ul>
      <li>MySQL, MariaDB, Oracle, SQLite, DB2, SQL Server, PostgreSQL, …</li>
      <li>계층형(Hierarchical), 망형(Network), 관계형(Relational), 객체지향형(Object-Oriented), 객체관계형(Object-Relational) 등으로 분류할 수 있으나 현재는 RDBMS를 제외하고는 거의 사용되지 않는다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h4 id="관계형-데이터-베이스란">관계형 데이터 베이스란?</h4>

<ul>
  <li>데이터를 열(column)과 행(row)으로 구성된 테이블(table)에 저장</li>
  <li>각 열은 하나의 속성에 대한 정보를 저장하고, 행은 각 열의 데이터 형식에 맞는 데이터가 저장된다.</li>
  <li>테이블의 구조와 데이터 타입 등을 사전에 정의하고, 해당 테이블에 알맞은 형태의 데이터만 삽입할 수 있다.</li>
</ul>

<p><br /></p>

<h4 id="sql-이란">SQL 이란?</h4>

<blockquote>
  <p>Structured Query Language</p>
</blockquote>

<ul>
  <li>관계형 데이터 베이스에서 사용되는 언어</li>
  <li>관계형 데이터 베이스에서 모두 SQL이라는 언어를 사용하므로 관계형 데이터 베이스를 총칭해서 SQL이라고 부르기도 한다.</li>
</ul>

<p><br /></p>

<blockquote>
  <p>☝️ 여기서 잠깐!</p>

  <p>SQL은 누가 만드나요?</p>

  <ul>
    <li>국제 표준화 기구에서 SQL에 대한 표준을 정해서 발표하고 있고, 이를 표준 SQL이라고 한다.</li>
    <li>다만 표준 SQL이 각 회사의 DBMS 특성을 모두 포용하지 못하기 때문에 표준 SQL을 준수하되 각 제품의 특성을 추가한 SQL을 사용한다.</li>
    <li>Oracle은 PL/SQL, SQL Server는 T-SQL, MySQL은 SQL로 명칭한다.</li>
  </ul>
</blockquote>

<p><br /><br /></p>

<h4 id="비관계형-데이터-베이스의-등장-배경">비관계형 데이터 베이스의 등장 배경</h4>

<p>관계형 데이터 베이스는 20년 이상 데이터 베이스 시장을 지배했는데, 기술과 빅데이터 응용 프로그램이 발전함에 따라 SQL 기반 데이터베이스는 빠르게 확장되는 데이터의 양과 복잡해지는 데이터 구조를 처리하기에 한계에 부딪혔다. 이를 해결하기 위해 CPU나 메모리를 추가하는 방편을 사용했지만 이 방식은 비싸고 임시 방편일 뿐이었다.</p>

<p>대표적인 인터넷 기업이면서 대용량 단순 데이터를 많이 보유해 단순 대용량 데이터 처리에 대한 요구가 가장 많은 구글과 아마존에 의해 Bigtable과 Dynamo라는 논문이 발표되었고, 이 두 논문은 새로운 데이터 저장 기술을 만들어내는 시발점이 됐다.</p>

<p>결국 대용량 데이터 관리 작업에 필요한 유연하고, 확장 가능하며, 비용적으로 효율적이면서 높은 가용성을 가지는 데이터 베이스 스키마를 재설계하게 됐고, 이것이 NoSQL이다.</p>

<p><br /><br /><br /></p>

<h1 id="nosql">NoSQL</h1>

<blockquote>
  <p>Not Only SQL</p>
</blockquote>

<ul>
  <li>비관계형 데이터 베이스</li>
  <li>
    <p>관계형 데이터 베이스 이외의 형식으로 데이터를 저장하는 데이터 베이스를 총칭</p>
  </li>
  <li>
    <p>RDBMS의 한계를 극복하기 위해 Join이 없고, 고정된 스키마를 갖지 않는 새로운 형태의 데이터 저장소</p>
  </li>
  <li>Document, Graph, Key-Value, Column Store 등의 방식이 있다.</li>
</ul>

<p><br /></p>

<h4 id="특징">특징</h4>

<ul>
  <li>RDBMS와 달리 데이터 간의 관계를 정의하지 않는다.
    <ul>
      <li>관계형 데이터 베이스가 데이터의 관계를 Foreign Key 등으로 정의하고 이를 이용해 Join 등의 관계형 연산을 한다고 한다면, NoSQL은 데이터 간의 관계를 정의하지 않는다.</li>
    </ul>
  </li>
  <li>
    <p>RDBMS에 비해 훨씬 대용량의 데이터를 저장 가능</p>
  </li>
  <li>분산형 구조를 통해 여러 대의 서버에 분산해 저장하고 상호 복제해 데이터 유실이나 서비스 중지에 대비 가능 <code class="language-plaintext highlighter-rouge">확장성</code> <code class="language-plaintext highlighter-rouge">가용성</code>
    <ul>
      <li>RDBMS는 보통 하나의 고성능 머신에 데이터를 저장함</li>
    </ul>
  </li>
  <li>고정되지 않은 테이블 스키마 (테이블의 스키마가 유동적) <code class="language-plaintext highlighter-rouge">유연성</code>
    <ul>
      <li>데이터 베이스 설계를 변경하지 않고도 필요한 속성을 동적으로 추가할 수 있다.</li>
    </ul>
  </li>
  <li>읽기 작업보다 쓰기 작업이 더 빠르고, 일반적으로 RDBMS에 비해 쓰기와 읽기 성능이 빠르다. <code class="language-plaintext highlighter-rouge">고성능</code>
    <ul>
      <li>대량의 데이터를 빠르게 처리하기 위해 메모리에 임시 저장하고 응답하는 등의 방법을 사용</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="nosql-종류">NoSQL 종류</h2>

<h3 id="key-value-db">Key-Value DB</h3>

<blockquote>
  <p>Redis, Oracle NoSQL, Voldemorte, …</p>
</blockquote>

<p><img src="/assets/img/posts/cs/db/5-3_key-value-db.png" alt="Key-Value DB" /></p>

<ul>
  <li>
    <p>Amazon의 Dynamo Paper에서 유래</p>
  </li>
  <li>
    <p>Key와 Value의 쌍으로 데이터가 저장되는 유형</p>
  </li>
  <li>
    <p>Key는 값에 접근하기 위한 용도이고 (Unique 값)</p>

    <p>Value에는 어떤 형태의 데이터(이미지, 비디오 포함)도 담을 수 있다.</p>
  </li>
  <li>
    <p>간단한 API를 제공해 질의 속도가 굉장히 빠름</p>
  </li>
</ul>

<p><br /></p>

<h4 id="언제-사용하는게-좋을까">언제 사용하는게 좋을까?</h4>

<ol>
  <li>성능 향상을 위해 관계형 데이터 베이스에서 데이터 캐싱</li>
  <li>모바일 어플리케이션용 사용자 데이터 정보와 구성 정보 저장</li>
  <li>이미지나 오디오 파일 같은 대용량 객체 저장</li>
</ol>

<p><br /><br /></p>

<h3 id="doument-db">Doument DB</h3>

<blockquote>
  <p>MongoDB, Azure Cosmos DB, CouchDB, …</p>
</blockquote>

<p><img src="/assets/img/posts/cs/db/5-3_document-db.png" alt="Document DB" /></p>

<ul>
  <li>Lotus Notes에서 유래</li>
  <li>Key-Value 와 차이는 값을 문서로 저장한다는 점
    <ul>
      <li>여기서 문서란 JSON, XML과 같은 형식을 말한다.</li>
      <li>Document 내 객체는 서로 다른 필드를 가질 수 있음</li>
    </ul>
  </li>
  <li>데이터를 여러 서버에 분산 저장이 가능하고 복제와 회복이 가능한 형태라 장애가 발생해도 대응에 유리하다.</li>
  <li>단점이라면 쿼리가 SQL과 다르고, 질의 결과가 JSON이나 XML 형태로 출력된다는 점</li>
</ul>

<p><br /></p>

<h4 id="언제-사용하는게-좋을까-1">언제 사용하는게 좋을까?</h4>

<ol>
  <li>대용량 데이터를 읽고 쓰는 웹 사이트용 백엔드 지원</li>
  <li>다양한 유형의 메타 데이터 추적</li>
  <li>JSON 데이터 구조를 사용하는 어플리케이션</li>
</ol>

<p><br /><br /></p>

<h3 id="wide-column-db">Wide Column DB</h3>

<blockquote>
  <p>HBase, Cassandra, Hypertable, …</p>
</blockquote>

<p><img src="/assets/img/posts/cs/db/5-3_wide-column-db.png" alt="Wide Column DB" /></p>

<ul>
  <li>Big Table DB라고도 하며, Google의 BigTable Paper에서 유래</li>
  <li>Column Family 데이터 모델을 사용</li>
  <li>행마다 각각 다른 값과 다른 수의 스키마를 가질 수 있음
    <ul>
      <li>사용자 이름(Key)에 해당하는 값에 스키마들이 각각 다름</li>
    </ul>
  </li>
  <li>대량의 데이터의 압축, 분산 처리, 집계 처리 및 쿼리 동작 속도 그리고 확장성이 뛰어남</li>
</ul>

<p><br /></p>

<h4 id="언제-사용하는게-좋을까-2">언제 사용하는게 좋을까?</h4>

<ul>
  <li>열이 모든 행에 대해 항상 동일하지 않고, 여러 데이터 베이스 노드에 분산될 수 있는 대규모 데이터 셋이 필요할 때 사용하는 것이 이상적</li>
</ul>

<ol>
  <li>Log data 저장</li>
  <li>주식 거래 데이터나 기온 모니터링 데이터 등 시계열 데이터 저장</li>
</ol>

<p><br /><br /></p>

<h3 id="graph-db">Graph DB</h3>

<blockquote>
  <p>Neo4J, Blasegraph, OrientDB</p>
</blockquote>

<p><img src="/assets/img/posts/cs/db/5-3_graph-db.png" alt="Graph DB" /></p>

<ul>
  <li>Euler &amp; Graph Theory에서 유래</li>
  <li>노드, 엣지, 프로퍼티와 함께 그래프 구조를 사용해 데이터를 표현하고 저장</li>
  <li>
    <p>질의가 그래프 순회를 통해 이루어진다.</p>
  </li>
  <li>RDBMS보다 성능이 좋고 유연하며 유지보수에 용이하다.</li>
  <li>클러스터링에 적합하지 않고 질의 언어도 특화되어 있어 배우기 어렵다.</li>
</ul>

<p><br /></p>

<h4 id="언제-사용하는게-좋을까-3">언제 사용하는게 좋을까?</h4>

<ul>
  <li>
    <p>데이터 간의 관계가 탐색의 키일 경우</p>

    <ol>
      <li>
        <p>페이스북이나 트위터 같은 SNS 에서 내 친구의 친구를 찾는 질의 등에 적합하고,</p>
      </li>
      <li>
        <p>연관된 데이터를 추천해주는 추천 엔진이나 패턴 인식 등의 데이터 베이스로도 적합</p>
      </li>
    </ol>
  </li>
</ul>

<p><br /></p>

<h2 id="nosql-vs-sql">NoSQL vs SQL</h2>

<h4 id="1-스키마">1) 스키마</h4>

<ul>
  <li>DB의 구조, 제약조건에 관한 명세
    <ul>
      <li>개체의 특징을 나타내는 <strong>속성(Attribute)</strong></li>
      <li>속성들의 집합으로 이루어진 <strong>개체(Entity)</strong></li>
      <li>개체 간 존재하는 <strong>관계(RelationShip)</strong></li>
    </ul>
  </li>
</ul>

<table>
  <thead>
    <tr>
      <th> </th>
      <th>SQL</th>
      <th>NoSQL</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>Table에 데이터가 저장됨 (2차원 테이블로 모델링)</td>
      <td>Document에 저장됨<br />Document가 모여 Collection<br />Collection이 모여 Database</td>
    </tr>
    <tr>
      <td>2</td>
      <td>Row, Col 구조</td>
      <td>Key-Value 형태로 데이터 저장</td>
    </tr>
    <tr>
      <td>3</td>
      <td>스키마를 정의 해야 데이터를 저장할 수 있음</td>
      <td>스키마를 정의하지 않아도 된다.</td>
    </tr>
  </tbody>
</table>

<p><br /><br /></p>

<h4 id="2-relation관계">2) Relation(관계)</h4>

<table>
  <thead>
    <tr>
      <th> </th>
      <th>SQL</th>
      <th>NoSQL</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>SQL에서 가장 중요</td>
      <td>Join 이란 개념이 없음</td>
    </tr>
    <tr>
      <td>2</td>
      <td>Table간의 관계(Join)을 통해 데이터를 파악할 수 있음</td>
      <td>Users 의 데이터가 Orders에 다 담김. -&gt; Join을 통해 확인 X</td>
    </tr>
    <tr>
      <td>3</td>
      <td>데이터를 중복 없이 저장 가능(정규화 필요)</td>
      <td>Collections 별로 중복된 데이터 존재<br />-&gt; 업데이트 할 때 주의 필요</td>
    </tr>
  </tbody>
</table>

<p><br /><br /></p>

<h4 id="3-scalability확장">3) Scalability(확장)</h4>

<table>
  <thead>
    <tr>
      <th> </th>
      <th>SQL</th>
      <th>NoSQL</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>특징</td>
      <td><strong>Vertical</strong></td>
      <td><strong>Horizontal</strong></td>
    </tr>
    <tr>
      <td> </td>
      <td>= Scale up</td>
      <td>= Scale out</td>
    </tr>
    <tr>
      <td> </td>
      <td>성능을 향상시키는 것</td>
      <td>더 많이 서버를 늘리는 것</td>
    </tr>
  </tbody>
</table>

<p><br /><br /></p>

<h4 id="4-property특성">4) Property(특성)</h4>

<table>
  <thead>
    <tr>
      <th> </th>
      <th>SQL</th>
      <th>NoSQL</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>특징</td>
      <td><strong>ACID</strong></td>
      <td><strong>CAP</strong> (ACID를 완벽히 구현하지 않고 “Eventual consistency” 개념을 도입.)</td>
    </tr>
    <tr>
      <td> </td>
      <td>트랜잭션이 안전하게 수행되도록 보장하는 것</td>
      <td>CAP 의 Consistency나 Avaliability를 포기해 분산 확장성을 보장</td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>A+P : 비동기식 서비스<br />C+P : 성능 보장형 대용량 분산 파일 시스템</td>
    </tr>
    <tr>
      <td> </td>
      <td>Atomicity(원자성) : 트랜잭션의 작업이 부분적으로 실행되거나 중단되지 않는 것을 보장</td>
      <td>트랜잭션 ACID를 느슨하게 유지</td>
    </tr>
    <tr>
      <td> </td>
      <td>Consistency(일관성) : 미리 정의된 규칙에서만 수정이 가능한 특성 (숫자 컬럼에 문자열 값 저장 안되도록 보장)</td>
      <td>Consistency (일관성) : 모든 요청은 최신 데이터 또는 에러를 응답  (DB가 3개로 분산되었다고 가정할 때, 하나의 특정 DB의 데이터가 수정되면 나머지 2개의 DB에서도 수정된 데이터를 응답받아야 한다.)</td>
    </tr>
    <tr>
      <td> </td>
      <td>Isolation(고립성) : 트랜잭션 수행시 다른 트랜잭션의 작업이 끼어들지 못하도록 보장</td>
      <td>Availability (가용성) : 모든 요청은 정상 응답을 받는다. (특정 DB가 장애가 나도 서비스가 가능해야 한다.)</td>
    </tr>
    <tr>
      <td> </td>
      <td>Durability(영구성) : 성공적으로 수행된 트랜잭션은 영원히 반영</td>
      <td>Partitions Tolerance (분리 내구성) : DB간 통신이 실패하는 경우라도 시스템은 정상 동작</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>NoSQL은 분산형의 특성상 정보의 일관성을 유지하기가 어렵다. 수많은 머신에 데이터를 분산저장했는데 한 영역에 Update가 생길 시 그것을 실시간으로 다른 영역에 전파하는 것이 쉽지만은 않기 때문이다.  반드시 어느 정도의 전파 비용은 수반될 수밖에 없다. <strong>그래서 NoSQL은 Consistency를 조금 타협하고 꼭 실제 최신은 아닐 수 있지만 “업데이트가 되기 전까지는” 가지고 있는 최신의 데이터를 반환한다는 “Eventual Consistency”라는 개념을 사용한다.</strong></li>
</ul>

<p><br /></p>

<blockquote>
  <p>여기서 잠깐!</p>

  <p>☝️ ACID 란?</p>

  <p>트랜잭션은 여러 개의 작업을 하나로 묶어 모든 작업들을 완료해야 정상적으로 종료되는 실행 유닛이고, ACID는 데이터 베이스에서 트랜잭션의 안전성을 보장하기 위한 성질입니다.</p>

  <p>예를 들면, 계좌 이체에서 나의 계좌에서 10만원을 빼고, A에게 10만원을 추가하는 종합적인 과정이 트랜잭션입니다.</p>
</blockquote>

<p><br /></p>

<blockquote>
  <p>여기서 잠깐!</p>

  <p>✌️ CAP 이란?</p>

  <p>2002년 버클리 대학의 Eric Brewer 교수가 발표한 분산 컴퓨팅 이론으로, 분산 컴퓨팅 환경에서 일관성, 가용성, 분산 가용성 세 가지 특징을 보장해야 함을 정의하고, 분산 시스템은 이중 두 가지만 만족할 수 있다는 이론이다.</p>
</blockquote>

<p><br /><br /></p>

<h3 id="그래서-둘-중에-뭘-선택해야-하는가">그래서 둘 중에 뭘 선택해야 하는가?</h3>

<p>정답은 없다. 어떤 데이터를 다루느냐에 따라 달라진다.</p>

<p><br /></p>

<h4 id="sql-데이터-베이스-사용이-더-좋을-때">SQL 데이터 베이스 사용이 더 좋을 때</h4>

<ul>
  <li>관계를 맺고 있는 데이터가 자주 변경되는 어플리케이션</li>
  <li>변경될 여지가 없는 명확한 스키마가 사용자와 데이터에게 중요한 경우</li>
  <li>데이터베이스의 ACID 성질을 준수해야 하는 경우 (금융 서비스)</li>
</ul>

<p><br /></p>

<h4 id="nosql-데이터-베이스-사용이-더-좋을-때">NoSQL 데이터 베이스 사용이 더 좋을 때</h4>

<ul>
  <li>
    <p>정확한 데이터 구조를 알 수 없거나 변경/확장 될 수 있는 경우</p>
  </li>
  <li>읽기를 자주 하지만, 데이터 변경은 자주 없는 경우</li>
  <li>데이터 정합성이나 일관성이 최고 우선순위가 아닌 경우</li>
  <li>데이터베이스를 수평으로 확장해야 하는 경우 (막대한 양의 데이터를 다뤄야 하는 경우)</li>
</ul>

<p><br /><br /><br /></p>

<h1 id="replication-vs-clustering">Replication vs Clustering</h1>

<ul>
  <li>리플리케이션은 여러 개의 DB를 수직적인 구조(Master-Slave)로 구축하는 방식
    <ul>
      <li>데이터 베이스 서보와 스토리지를 모두 확장</li>
    </ul>
  </li>
  <li>클러스터링은 여러 개의 DB를 수평적인 구조로 구축하는 방식
    <ul>
      <li>데이터 베이스 서버를 확장</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="replication">Replication</h2>

<ul>
  <li>여러 개의 DB를 권한에 따라 수직 구조로 구축하는 방식.</li>
  <li>데이터 베이스 서버와 스토리지를 모두 확장</li>
  <li>Master Node는 쓰기 작업만, Slave Node는 읽기 작업만. (기존의 부하를 분산)</li>
  <li>비동기 방식으로 노드 데이터 동기화</li>
</ul>

<p><br /></p>

<p><a href="https://github.com/workhardslave/cs-study/blob/main/Database/img/nosql5.png"><img src="https://github.com/workhardslave/cs-study/raw/main/Database/img/nosql5.png" alt="qwd" /></a></p>

<ol>
  <li>Master Node에 쓰기 작업 실행</li>
  <li>데이터를 저장하고 트랜잭션 로그를 파일에 기록(BinLog)</li>
  <li>Slave Node IO Thread는 BinLog를 복사</li>
  <li>Slave 노드의 SQL Thread는 파일을 읽으며 데이터 저장</li>
</ol>

<p><br /></p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th>장점</th>
      <th>단점</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>읽기 작업이 많은 DB 요청에서는 Replication만으로 충분히 성능 높이기 가능</td>
      <td>Master 노드가 다운되면 복구, 대처가 까다로움</td>
    </tr>
    <tr>
      <td>2</td>
      <td>비동기 방식이라 지연 시간이 거의 없음</td>
      <td>동기화가 보장되지 않아 일관성 있는 데이터 신뢰 불가</td>
    </tr>
  </tbody>
</table>

<p><br /><br /></p>

<h2 id="clustering">Clustering</h2>

<ul>
  <li>여러 개의 DB를 수평 구조로 구축하는 방식.  (데이터 베이스 서버 확장)</li>
  <li>Fail Over 시스템을 구축하기 위해 사용.
    <ul>
      <li>데이터 베이스가 동작하지 않으면 전체 서비스가 동작할 수 없다는 점을 해결하기 위해 Clustering을 통해 데이터 베이스 서버를 늘린다.</li>
    </ul>
  </li>
  <li>동기 방식으로 노드들 간의 데이터 동기화</li>
</ul>

<p><br /></p>

<p><a href="https://github.com/workhardslave/cs-study/blob/main/Database/img/nosql6.png"><img src="https://github.com/workhardslave/cs-study/raw/main/Database/img/nosql6.png" alt="qwd" /></a></p>

<ol>
  <li>1개의 노드에 쓰기 트랜잭션 수행</li>
  <li>실제 디스크에 내용을 쓰기 전에 다른 노드로 데이터 복제 요청</li>
  <li>다른 노드에서 복제 요청 수락 신호를 보내고, 디스크에 쓰기 시작</li>
  <li>다른 노드로부터 신호를 받으면 실제 데이터 저장</li>
</ol>

<p><br /></p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th>장점</th>
      <th>단점</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>노드들 간의 데이터를 동기화하여 일관성 있는 데이터 신뢰</td>
      <td>Replication에 비해 쓰기 성능이 떨어짐</td>
    </tr>
    <tr>
      <td>2</td>
      <td>1개의 노드가 죽어도 다른 노드가 살아있어, 시스템을 장애 없이 운영</td>
      <td>장애가 전파된 경우 처리가 까다로움.</td>
    </tr>
  </tbody>
</table>

<p><br /><br /><br /></p>

<h1 id="sharding">Sharding</h1>

<ul>
  <li>
    <p>같은 테이블 스키마를 가진 데이터를 다수의 데이터베이스에 분산하여 저장하는 방법.</p>

    <p>= Horizontal Partitioning</p>
  </li>
  <li>
    <p>DB 트래픽을 분산할 목적</p>

    <ul>
      <li>데이터가 급격히 증가하게 되거나 <strong>트래픽이 특정 DB로 몰리는 상황을 대비</strong>해서 빠르고 유연하고 안전하게 DB를 증설할 수 있게 한다. (DB 서버의 부하를 분산)</li>
      <li>Scale-up 에는 한계가 있고, Scale-out은 동기화라는 제약이 따르게 되므로 DB 서버의 샤딩은 대규모 시스템 설계와 확장성 확보에 필수 불가결인 요소가 된다.</li>
    </ul>
  </li>
  <li>
    <p>다수의 복제본으로 구성하고 각 샤드에 어떤 데이터가 저장될 지를 Shard Key를 기준으로 분리한다.</p>
  </li>
  <li>
    <p>Shard Key를 어떻게 정의하느냐에 따라 데이터를 효율적으로 분산시키는 것이 결정됨</p>
  </li>
</ul>

<p><br /></p>

<p><a href="https://github.com/workhardslave/cs-study/blob/main/Database/img/nosql7.png"><img src="https://github.com/workhardslave/cs-study/raw/main/Database/img/nosql7.png" alt="qwd" /></a></p>

<p><br /></p>

<h3 id="샤딩-적용시-문제점-및-고려사항">샤딩 적용시 문제점 및 고려사항</h3>

<ol>
  <li>데이터 재분배 (Rebalancing Data)
    <ul>
      <li>샤딩된 DB의 물리적 한계나 성능 한계 도달 시 scale-up 작업이 필요한데,</li>
      <li>이때 서비스 정지 없이 scale-up 할 수 있도록 설계 방향 잡아야 한다.</li>
    </ul>
  </li>
  <li>데이터 조인하기
    <ul>
      <li>샤딩 DB 간 조인이 불가능 하므로 데이터 중복에 대한 trade-off</li>
    </ul>
  </li>
  <li>
    <p>Global Unique Key</p>

    <p>DBMS에서 제공하는 auto-increament를 사용하면 Key가 중복될 수 있기 때문에 어플리케이션 레벨에서 Key 생성을 담당해야 한다.</p>

    <p>=&gt; <strong>라우팅을 위해 구분할 수 있는 유일한 키값이 있어야 한다.</strong></p>
  </li>
  <li>
    <p>프로그래밍 복잡도가 증가하고, 데이터가 한 쪽 샤드로 몰리면 샤딩이 무의미해짐</p>
  </li>
  <li>한 번 샤딩 사용하면 샤딩 이전 구조로 돌아가기 힘들다.</li>
</ol>

<p><br /></p>

<h4 id="샤딩-방법">샤딩 방법</h4>

<ul>
  <li>Hash Sharding : 데이터를 어디에 넣을지 해싱하여 결정</li>
  <li>Dynamic Sharding : Locator Service 를 통해 동적 샤딩 키를 얻어 사용</li>
  <li>Entity Group : 관련된 데이터를 하나의 샤드로 사용하는 방식</li>
</ul>

<p><br /><br /><br /></p>

<h1 id="면접-질문">면접 질문</h1>

<h4 id="데이터베이스란">데이터베이스란?</h4>

<p>데이터 베이스는 데이터의 저장소입니다.</p>

<p><br /><br /></p>

<h4 id="데이터-베이스는-왜-등장했나요">데이터 베이스는 왜 등장했나요?</h4>

<p>데이터 베이스를 사용하기 전에는 파일 시스템을 이용해 데이터를 관리했습니다. 이때 데이터가 중복해서 저장되거나, 어플리케이션에 종속성 문제가 발생해 데이터를 체계적으로 관리하는데 한계가 있었기 때문에 데이터를 보다 효율적이고 문제없이 관리하기 위해 데이터 베이스를 사용하게 됐습니다.</p>

<p><br /><br /></p>

<h4 id="데이터-베이스는-어떻게-관리하나요">데이터 베이스는 어떻게 관리하나요?</h4>

<p>DBMS, 데이터 베이스 관리 시스템이라고 불리는 소프트웨어를 통해 관리합니다.</p>

<p>DBMS는 다수의 사용자가 DB를 통해 데이터를 검색하거나 저장하기 편리하고 효율적인 환경을 제공해줍니다.</p>

<p><br /></p>

<ul>
  <li>(추가) 알고 있는 DBMS에는 MySQL, Oracle, SQLite, MongoDB 등이 있습니다.</li>
</ul>

<p><br /><br /></p>

<h4 id="데이터-베이스에는-어떤-종류가-있나요">데이터 베이스에는 어떤 종류가 있나요?</h4>

<p>현재 많이 사용하는 데이터 베이스에는 크게 관계형 데이터 베이스와 NoSQL 이 있습니다.</p>

<p><br /><br /></p>

<h4 id="사용해보신-db-종류가-어떤-게-있나요">사용해보신 DB 종류가 어떤 게 있나요?</h4>

<p>졸업 프로젝트로 사용자가 촬영한 사진을 통해 재료를 인식해 ‘모바일 냉장고’에 넣고, 해당 재료로 레시피를 추천하는 웹 프로그램을 만들었습니다. 그 때 모바일 냉장고에 재료를 저장하기 위해 SQLite 를 사용해 DB를 구축했습니다.</p>

<p><br /><br /></p>

<h4 id="사용해본-db에-대해-설명해주세요">사용해본 DB에 대해 설명해주세요.</h4>

<p>SQLite는 낮은 메모리 환경에서도 좋은 성능을 내기로 알려진 오픈 소스 관계형 데이터 베이스입니다. 선택한 가장 큰 이유이기도 한 장점은 우선 무료이고, 공간 차지가 적으며 빠릅니다.</p>

<p>단점으로는 동시성에 제한이 있다는 점과 다른 RDBMS보다 보안이 약하다는 점이 있습니다. 하지만 진행한 프로젝트는 상업 용도가 아니었기 때문에 AWS 비용 문제로 인해 빠르고 공간 차지가 적은 SQLite을 선택해 사용했습니다.</p>

<p><br /><br /></p>

<h4 id="nosql을-사용하여-프로젝트를-해본-적은-있나요-프로젝트에-대한-간략한-소개와-왜-해당-db를-사용했는지">NoSQL을 사용하여 프로젝트를 해본 적은 있나요? 프로젝트에 대한 간략한 소개와 왜 해당 DB를 사용했는지?</h4>

<p>챗봇 프로젝트에서 mongoDB를 사용한 경험이 있습니다. 해당 프로젝트는 심리 컨텐츠를 사용자에게 설명해주는 챗봇을 개발하는 프로젝트로, 사용자의 정보와 질의응답 등을 DB에 저장할 필요가 있었습니다.</p>

<p>당시 챗봇이 앞으로 더 많은 기능을 추가할 예정이라 이에 따라 DB 구조가 변경될 가능성이 컸고 챗봇 구축을 RASA로 했는데 python 언어를 사용했기 때문에 mongoDB를 선택했습니다.</p>

<p><br /></p>

<ul>
  <li>(추가) mongoDB의 단점
    <ul>
      <li>mongoDB는 CASCADE 기능을 지원하지 않아, 자주 변경되는 데이터를 저장하면 오히려 성능 저하 문제가 있다는 점</li>
    </ul>
  </li>
</ul>

<p><br /><br /></p>

<h4 id="sql과-nosql의-특성을-설명해주세요">SQL과 NoSQL의 특성을 설명해주세요</h4>

<p>SQL은 관계형 데이터베이스를 총칭하는 말로, 데이터를 열과 행으로 구성된 테이블에 저장하고, 미리 정의된 형태의 데이터만 삽입할 수 있고, 트랜잭션 수행을 보장합니다.</p>

<p>NoSQL은 비관계형 데이터베이스를 총칭하는 말로, SQL과 달리 관계를 정의하지 않아 정해진 데이터 구조가 없고 읽기 쓰기 성능이 빠릅니다.</p>

<p><br /><br /></p>

<h4 id="nosql에는-어떤-종류가-있나요">NoSQL에는 어떤 종류가 있나요?</h4>

<p>NoSQL은 데이터를 저장하는 방식에 따라 다른데, 저는 Key-Value DB, Document DB, Wide Column DB, Graph DB 를 알고 있습니다.</p>

<p>Key-Value DB는 말 그대로 key와 value 쌍으로 데이터가 저장되는 유형으로 key는 값에 접근하기 위한 unique 한 값을 갖고, value에는 문자열 뿐 아니라 이미지나 비디오 등 어떤 형태의 데이터든 담을 수 있습니다.</p>

<p>Document DB는 Key-Value DB와 유사하나 Value가 JSON 이나 XML 형식의 문서라는 점이 다릅니다.</p>

<p>Wide Column DB는 행마다 다른 값과 다른 수의 스키마를 가질 수 있는 DB입니다.</p>

<p>Graph DB는 그래프 구조로 데이터를 표현하고 저장하며 질의도 그래프 순회로 이루어지는 DB입니다.</p>

<p><br /><br /></p>

<h4 id="본인이라면-rdb와-nosql-기술을-결정해야-할-때-어떤-기준을-가지고-결정하시겠어요">본인이라면 RDB와 NoSQL 기술을 결정해야 할 때 어떤 기준을 가지고 결정하시겠어요?</h4>

<p>저장할 데이터에 따라 다를 것 같습니다. 만약 데이터의 구조가 명확하고 관계를 맺는 데이터가 자주 변경된다면, 또는 금융 서비스처럼 트랜잭션이 보장되어야 할 때는 RDB를 선택할 것입니다.</p>

<p>반면 정확한 데이터 구조가 없거나 변경될 수 있는 경우거나, 변경보다는 읽는 작업이 많을 때, 또는 다뤄야 하는 데이터의 양이 매우 많을 때는 NoSQL을 사용할 것입니다.</p>

<p><br /><br /></p>

<h4 id="데이터-베이스를-확장하는-방법은">데이터 베이스를 확장하는 방법은?</h4>

<p>데이터를 확장하는 방법으로는 수직적으로 확장하는 리플리케이션, 수평적으로 확장하는 클러스터링, 그리고 수평적으로 분할하는 샤딩이 있습니다.</p>

<p><br /><br /></p>

<h4 id="리플리케이션-vs-클러스터링">리플리케이션 vs 클러스터링</h4>

<p>리플리케이션은 여러 개의 DB를 수직적인 구조로 구축하는 방식입니다. 하나의 master DB에서는 쓰기 작업만 하고, 여러 개의 slave DB에서는 읽기 작업만 함으로 기존의 트래픽을 분산합니다.</p>

<p>클러스터링은 여러 개의 DB를 수평적인 구조로 구축하는 방식입니다. 서버를 확장해서 Fail over 시스템을 구축하기 위해 주로 사용하는데, 하나의 DB가 동작하지 않더라도 다른 DB를 통해 계속해서 서비스를 제공할 수 있도록 하는 방식입니다.</p>

<p><br /><br /></p>

<h4 id="클러스터링의-단점은">클러스터링의 단점은?</h4>

<p>일반적으로 리플리케이션에 비해 성능이 떨어지고 동기화 방식이기 때문에 만약 에러가 전파되면 처리하기 까다롭다는 단점이 있습니다.</p>

<p><br /><br /></p>

<h4 id="리플리케이션의-단점은">리플리케이션의 단점은?</h4>

<p>리플리케이션은 비동기 방식이기 때문에 일관성 있는 데이터 신뢰가 불가능하고, 만약 Master 노드가 다운되면 복구나 대처가 까다롭다는 단점이 있습니다.</p>

<p><br /><br /></p>

<h4 id="가장-큰-데이터를-다룬-프로젝트는-무엇인가요-데이터-양이-많아질-때-어떻게-하면-효율적으로-관리가-가능할까요">가장 큰 데이터를 다룬 프로젝트는 무엇인가요? 데이터 양이 많아질 때 어떻게 하면 효율적으로 관리가 가능할까요?</h4>

<p>챗봇 프로젝트가 가장 큰 데이터를 다룬 프로젝트였습니다. 사실 해당 프로젝트에서는 DB 확장이 필요할만큼의 대용량 데이터는 아니라 확장과 관련된 기술을 적용해본 경험은 없습니다. 만약 데이터 양이 많아진다면 DB를 확장하거나 혹인 리플리케이션 방식으로 트래픽을 분산해 관리할 것 같습니다.</p>

<p>하지만 RDB를 사용한다면 그 외에도 샤딩 방식으로 데이터를 분산 저장해 관리하는 방법도 생각해볼 것 같습니다.</p>

<p><br /><br /></p>

<h4 id="db-샤딩이란">DB 샤딩이란?</h4>

<p>DB 샤딩이란 같은 테이블 스키마를 가진 데이터를 다수의 DB에 분산해 저장하는 방법으로, DB 트래픽을 분산하기 위해 수행합니다.</p>

<p><br /></p>

<ul>
  <li>
    <p>(추가) DB 샤딩의 문제점 및 고려사항</p>

    <p>샤딩 DB 간 Join 연산이 불가하기 때문에 trade-off가 발생하고, 만약 한 쪽 샤드로 몰리면 샤딩이 무의미해지므로 분산 저장을 위한 샤딩 키를 적절하게 잘 찾는 것이 성능에 큰 영향을 미치게 됩니다.</p>

    <p>또 샤딩은 적용하면 이전 구조로 돌아가기 어렵다 것도 고려해야합니다.</p>
  </li>
</ul>

<p><br /><br /></p>

<h4 id="교착상태의-조건-4가지">교착상태의 조건 4가지</h4>

<p>교착상태는 한 리소스는 한 번에 한 프로세스만 사용할 수 있고, 강제로 리소스를 뺏을 수 없는 상황에서 hold and wait 관계의 프로세스들이 환형으로 기다리고 있는 상황에 발생합니다.</p>

<p><br /><br /></p>

<h4 id="트랜잭션-고립-수준에-대해서-아는대로-설명해주세요">트랜잭션 고립 수준에 대해서 아는대로 설명해주세요</h4>

<p><br /><br /></p>

<h2 id="추가">추가</h2>

<h4 id="dynamic-sharding-단점">Dynamic sharding 단점</h4>

<p>Locator에 의존해야 한다는 단점이 있습니다. 만약 Lacator가 성능을 위해 Cache 하면 잘못된 routing으로 인해 Error가 발생할 수 있습니다.</p>

<p><br /><br /></p>

<h4 id="nosql의-의의">NoSQL의 의의</h4>

<p>NoSQL이 RDBMS를 대체할 수는 없지만, NoSQL은 그만의 장점이 뚜렷합니다.</p>

<p>로그 데이터처럼 매 초 엄청난 양이 생성되지만 한 번 저장되면 수정될 일이 거의 없는 류의 데이터를 효율적으로 저장할 수 있고, 특히 분산형 구조를 통해 여러 대의 장비에 빠른 속도로 저장하고 데이터가 많이 누적되더라도 수평적 확장이 용이합니다.</p>

<p><br /><br /><br /></p>

<h1 id="references">References</h1>

<ul>
  <li><a href="https://github.com/workhardslave/cs-study/blob/main/Database/NoSql%2C%20%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0%EB%A7%81vs%20%EB%A6%AC%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%2C%20DB%EC%83%A4%EB%94%A9.md">workhardslave/cs-study/Database</a></li>
  <li><a href="https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&amp;blogId=utis&amp;logNo=220472055509">데이터의 종속성/중복성/무결성</a></li>
  <li>
    <p><a href="https://hongong.hanbit.co.kr/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-databasedb-dbms-sql%EC%9D%98-%EA%B0%9C%EB%85%90/">Database, DBMS 개념</a></p>
  </li>
  <li><a href="https://velog.io/@swhan9404/NoSQL-%EC%9D%98-%EC%A2%85%EB%A5%98%EB%B3%84-%ED%8A%B9%EC%A7%95">NoSQL 종류별 특징</a></li>
  <li>
    <p><a href="https://mangkyu.tistory.com/97">Replication vs Clustering</a></p>
  </li>
  <li>
    <p><a href="https://tecoble.techcourse.co.kr/post/2021-09-18-replication_clustering/">Replication vs Clustering</a></p>
  </li>
  <li>
    <p><a href="https://goodgid.github.io/DB-Sharding/">DB Sharding</a></p>
  </li>
  <li><a href="https://jaehoney.tistory.com/245">DB Sharding</a></li>
</ul>]]></content><author><name>pino</name></author><category term="[&quot;CS&quot;, &quot;DB&quot;]" /><summary type="html"><![CDATA[TL;DR]]></summary></entry><entry><title type="html">Hash Table</title><link href="/cs/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/2022/10/21/DS_003.html" rel="alternate" type="text/html" title="Hash Table" /><published>2022-10-21T23:52:42+09:00</published><updated>2022-10-21T23:52:42+09:00</updated><id>/cs/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/2022/10/21/DS_003</id><content type="html" xml:base="/cs/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/2022/10/21/DS_003.html"><![CDATA[<h1 id="tldr">TL;DR</h1>

<h4 id="자료구조-빈출-유형-"><strong>자료구조 빈출 유형 !!!</strong></h4>

<ul>
  <li>해시 테이블은 키에 대한 해시 값을 사용해 값을 저장하고 조회하며, 키-값 쌍의 개수에 따라 동적으로 크기가 증가하는 Associate Array.</li>
  <li>해시 테이블은 적은 리소스로 많은 데이터를 효율적으로 관리할 수 있기 때문에 사용한다.</li>
  <li>해시 함수에는 <code class="language-plaintext highlighter-rouge">Division</code>, <code class="language-plaintext highlighter-rouge">Multiplication</code>, <code class="language-plaintext highlighter-rouge">Folding</code>, <code class="language-plaintext highlighter-rouge">Universal Hashing</code> 등 다양한 방법이 있다.</li>
  <li>충돌(Collision)을 처리하기 위해 링크드 리스트나 트리를 활용하는 <code class="language-plaintext highlighter-rouge">Chaining</code> 기법과 빈 공간에 저장하는 <code class="language-plaintext highlighter-rouge">Open Addressing</code> 방법을 사용한다.</li>
</ul>

<p><br /><br /><br /></p>

<h1 id="해시-테이블">해시 테이블</h1>

<ul>
  <li><code class="language-plaintext highlighter-rouge">해시(hash)</code> : 다양한 길이를 가진 데이터를 고정된 길이를 가진 데이터로 매핑한 값</li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">해시 함수</code> : 임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 함수</p>
  </li>
  <li>데이터가 조금만 달라져도 결과가 확연하게 달라져 <code class="language-plaintext highlighter-rouge">무결성</code>을 지키는데 도움을 주고,</li>
  <li>기본적으로 <code class="language-plaintext highlighter-rouge">복호화</code>가 불가능해 보안성을 지키는데 도움을 준다.</li>
</ul>

<p><br /><br /></p>

<h2 id="1-해시-테이블이란">1. 해시 테이블이란?</h2>

<p><img src="https://github.com/workhardslave/cs-study/raw/main/Data%20Structure/img/hash1.png" alt="img" /></p>

<ul>
  <li>키(Key)와 값(Value)을 매핑해 둔 데이터 구조</li>
  <li>키(Key)는 <strong>특별한 알고리즘을 이용해</strong> <strong>고유한 숫자를 만들어 낸 뒤</strong> 이를 인덱스로 사용한다.</li>
  <li>
    <p>데이터의 양이 아무리 많아지더라도 이론적으로 해시 변환, 검색, 삭제에 걸리는 시간은 $O(1)$ 로 <strong>매우 빠르다.</strong></p>
  </li>
  <li>
    <p>해시 테이블의 기본 개념은 데이터를 담을 테이블을 미리 크게 확보해 놓은 후 입력받은 데이터를 해시하여 테이블 내의 주소를 계산하고 이 주소에 데이터를 담는 것이다.</p>

    <p>따라서 특이하게도 데이터가 입력되지 않은 여유공간이 많아야 제 성능을 발휘할 수가 있다.</p>
  </li>
</ul>

<p><br /></p>

<h4 id="장점">장점</h4>

<ul>
  <li>
    <p>데이터 삽입, 삭제, 조회가 빠르다.</p>
  </li>
  <li>
    <p>적은 리소스로 많은 데이터를 효율적으로 관리할 수 있다.</p>

    <p>(하드디스크나, 클라우드에 존재하는 무한한 데이터들을 유한한 개수의 해시값으로 매핑하면 작은 메모리로도 프로세스 관리가 가능하다.)</p>
  </li>
</ul>

<p><br /></p>

<h4 id="단점">단점</h4>

<ul>
  <li>
    <p>순서를 보장하지 않아 순서/관계가 있는 목적에는 적합하지 않다.</p>

    <p>(데이터를 정렬된 순서로 접근할 때 비용이 높다.)</p>
  </li>
  <li>
    <p>지역 참조성에 취약하다.</p>
  </li>
</ul>

<p><br /><br /></p>

<h2 id="2-해시-함수">2. 해시 함수</h2>

<ul>
  <li>고유한 인덱스 값을 설정하는 특별한 알고리즘, Hash Function</li>
  <li>좋은 해시 함수는 특정 값에 치우치지 않고 해시값을 고르게 만들어낸다.</li>
</ul>

<p><br /></p>

<h3 id="1-division-method-나눗셈">1) Division Method 나눗셈</h3>

<ul>
  <li>숫자로 된 키를 해시테이블 크기 m으로 나눈 나머지를 해시값으로 반환</li>
  <li>m은 대게 소수를 사용하고, 2의 제곱수와 거리가 먼 소수를 사용하는 것이 좋다고 한다.</li>
</ul>

<p><br /></p>

<h3 id="2-multiplication-method-곱셈">2) Multiplication Method 곱셈</h3>

<ul>
  <li>숫자로 된 키가 $k$이고 $A$는 0과 1 사이의 실수일 때 실수의 곱셈법은 아래와 같이 정의된다.</li>
  <li>$m$이 얼마가 되든 크게 중요하지는 않고 보통 2의 제곱수로 정한다.</li>
  <li>2진수 연산에 최적화한 컴퓨터 구조를 고려한 해시함수라고 한다.</li>
</ul>

\[h(k) = (kA mod 1)xm\]

<p><br /></p>

<h3 id="3-digit-folding-자릿수-접기">3) Digit Folding 자릿수 접기</h3>

<ul>
  <li>키 값을 여러 부분으로 나눈 후 각 부분의 값을 더하거나 XOR 한 값을 해시값으로 삼기.</li>
  <li>ex) 583924를 각각 자릿수별로 더하면 31 -&gt; 이제 두 자리씩 Folding -&gt; 121</li>
</ul>

<p><br /></p>

<h3 id="4-universal-hashing-전체-해싱">4) Universal hashing 전체 해싱</h3>

<ul>
  <li>다수의 해시함수를 만들고 이 해시함수의 집합 H에서 무작위로 해시함수를 선택해 해시값을 만드는 기법</li>
  <li>H에서 무작위로 뽑은 해시함수가 주어졌을 때 임의의 키값을 임의의 해시값에 매핑할 확률을 1/m 로 만드려는 것이 목적</li>
  <li>아래의 특정 해시함수 집합 H는 이를 가능하게 한다고 수학적으로 증명됐다.
    <ul>
      <li>해시 테이블의 크기 m : 소수</li>
      <li>키값을 r+1 개로 쪼개기 : $k_0, k_1, …, k_r$</li>
      <li>0부터 m-1 사이의 정수 가운데 하나를 무작위로 뽑고, 분리된 키값의 개수(r+1)만큼 반복해서 뽑는다. 이를 $a = [a_0, a_1, …, a_r]$로 둔다.</li>
      <li>해시 함수 : $h_a(x) = \Sigma_{i=0}^r(a_i k_i mod m)$</li>
      <li>a가 $m_{r+1}$가지이므로, 해시함수의 집합 H의 요소 수 또한 $m_{r+1}$개이다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="보안과-해시">보안과 해시</h3>

<ul>
  <li>키와 해시값 사이에 직접적인 연관이 없어 해시 값 만으로는 키값을 복원하기 어렵고,</li>
  <li>해시 함수의 결과물은 고정된 길이의 숫자라 원래의 정보가 손실되어 원본데이터를 알기 어렵다.</li>
</ul>

<h4 id="5-md5-message-digest-algorithm">5) MD5 (Message-Digest Algorithm)</h4>

<ul>
  <li>임의의 길이의 값을 입력받아 128 비트의 고정 길이 해시값을 출력하는 알고리즘</li>
  <li>같은 입력값이면 항상 같은 출력값이 나오고, 서로 다른 입력값에서 같은 출력값이 나올 확률은 극히 낮다.</li>
  <li>패스워드 암호화에 많이 사용되고, 패스워드를 MD5로 해시해서 나온 값을 저장해둔다.</li>
  <li>보안 관련 용도로 쓰는 것을 권장하지 않는다.</li>
</ul>

<p><br /></p>

<h4 id="6-sha-secure-hash-algorithm">6) SHA (Secure Hash Algorithm)</h4>

<ul>
  <li>미국 국립표준기술연구소에서 표준으로 채택한 암호학적 해시 함수</li>
  <li>해시 길이에 따라 SHA-256, 384, 512 비트를 선택해 사용할 수 있고, 해시 길이가 길수록 안전하다.</li>
  <li>MD5보다 안전하지만 느리다.</li>
</ul>

<p><br /><br /></p>

<h2 id="3-충돌-처리-알고리즘">3. 충돌 처리 알고리즘</h2>

<ul>
  <li>
    <p>해시 테이블은 해시 함수에 의해 정해지는 Index가 중복될 수 있다는 문제가 존재한다.</p>
  </li>
  <li>위와 같은 상황을 충돌(Collision)이라고 한다.</li>
  <li>Collision이 많아질 수록 검색에 필요한 시간 복잡도가 $O(1)$에서 $O(N)$에 가까워진다.</li>
</ul>

<blockquote>
  <p>☝️ 여기서 잠깐!</p>

  <p>충돌 처리 알고리즘이 왜 필요할까?</p>

  <p>해시 함수를 무조건 1:1 로 만드는 것은 Array와 다를바 없고 메모리를 너무 많이 차지하게 된다. 따라서 Collision 을 최소화 하는 방향을 설계하고, 발생하는 Collision에 대비해 어떻게 대응할 것인가를 정하는 것이 더 중요하다.</p>
</blockquote>

<p><br /></p>

<h4 id="1-separate-chaining---분리-연결법">1. Separate Chaining - 분리 연결법</h4>

<p><img src="https://github.com/workhardslave/cs-study/raw/main/Data%20Structure/img/hash2.png" alt="img" /></p>

<ul>
  <li>
    <p>Linked List를 이용하는 방식</p>
  </li>
  <li>
    <p>각 Index에 데이터를 저장하는 Linked List에 대한 포인터를 가지고, 충돌이 발생하면 그 Index가 가리키고 있는 Linked List에 노드를 추가한다.</p>
  </li>
  <li>
    <p>데이터를 저장하는 구조는 Linked List만 사용하진 않는다.</p>

    <ul>
      <li>Java8의 Hashmap의 경우 Index 노드가 6개 이하일 경우에는 Linked List를,</li>
      <li>8개 이상으로 늘어날 때는 Self-Balancing Binary Search Tree 구조로 데이터 저장 구조를 바꾼다.</li>
    </ul>

    <blockquote>
      <p>☝️ 여기서 잠깐! WHY?</p>

      <p>Tree는 Linked List보다 메모리 사용량이 많고 데이터 개수가 적을 때 Tree와 Linked List의 Worst case 수행 시간 차이 비교가 의미없기 때문이다.  그러나 데이터 개수가 많아지면 Tree가 더 높은 성능을 보이게 된다.</p>

      <p>해시 함수 값이 균등분포일 때 Linked List에서는 get() 메소드의 기댓값은 E(N/M) 이고, Tree에서의 get() 메소드의 기댓값은 E(log N/M) 이므로 데이터의 개수가 일정 이상일 때에는 Linked List 대신 Tree를 사용하는 것이 성능상 이점이 있다.</p>

      <p>(<em>해시 테이블의 크기 m, 실제 사용하는 키 개수 n</em>)</p>
    </blockquote>

    <blockquote>
      <p>✌️ 여기서 잠깐!</p>

      <p>왜 기준이 6개, 8개인가?</p>

      <p>변경에 소요되는 비용을 줄이기 위해서다. 기준을 6개, 7개로 두게 된다면 하나의 값이 추가되면 자료구조를 변경해야 한다. 그리고 바로 하나의 값이 삭제되면 또 다시 자료구조를 변경해야 한다. 이런 Switching 비용 때문에 2개라는 여유를 두고 기준을 잡은 것이다.</p>
    </blockquote>

    <blockquote>
      <p>🤟 여기서 잠깐!</p>

      <p>왜 RB트리를 사용할까?</p>

      <p>해시 테이블은 데이터 조회만 많이 일어나는게 아니기 때문에 rotation 같이 밸런스를 유지하기 위해 드는 오버헤드가 크다.</p>

      <p>RB 트리는 느슨하게 균형을 유지하면서 조회, 삽입, 삭제에 평균적으로 좋은 퍼포먼스를 보여주기 때문에 사용한다.</p>
    </blockquote>
  </li>
</ul>

<p><br /></p>

<ul>
  <li>장점 : 테이블 확장을 늦출 수 있고, 간단하게 구현 가능.</li>
  <li>단점 : 동일한 버킷에 chaining 되는 데이터가 많아져서 캐시 효율성 감소한다는 단점
    <ul>
      <li>링크드 리스트 사용할 경우 최악의 경우 O(N)</li>
      <li>트리 활용의 경우 O(logN) 보장</li>
    </ul>
  </li>
</ul>

<p><br /><br /></p>

<h4 id="2-open-addressing---개방-주소법">2. Open Addressing - 개방 주소법</h4>

<ul>
  <li>
    <p>추가적인 메모리를 사용하지 않고 Hash Table의 빈 공간을 사용하는 방식</p>
  </li>
  <li>
    <p>여러가지 구현 방식이 있다.</p>

    <ul>
      <li>
        <p>Linear Probing : 현재 버킷 index로부터 고정폭 만큼씩 이동하여 차례대로 검색해 비어있는 버킷에 저장 (선형 탐색으로 빈공간 찾기)</p>
      </li>
      <li>
        <p>Quadratic Probing : 해시의 저장 순서 폭을 제곱으로 저장하는 방식</p>
      </li>
      <li>
        <p>Double Hashing : 해시된 값을 한번 더 해싱 (다른 해시 함수 사용)</p>
      </li>
    </ul>
  </li>
</ul>

<p><img src="https://github.com/workhardslave/cs-study/raw/main/Data%20Structure/img/hash3.png" alt="img" /></p>

<p><br /></p>

<ul>
  <li>삭제할 경우 충돌에 의해 뒤에 저장된 데이터가 검색되지 않을 수 있다. 이를 방지하기 위해 삭제한 위치에 Dummy Node를 삽입한다.</li>
  <li>장점 : 추가 메모리를 사용하지 않고 캐시 효율이 높다.</li>
  <li>단점
    <ul>
      <li>검색/삭제 시 Index의 키값이 찾고자 하는 키값이 아니라면 그 다음부터 선형 탐색을 실시해야 한다. (느리다!)</li>
      <li>해시 버킷을 채운 밀도가 높아질 수록 Worst Case 발생 빈도가 높아진다.</li>
    </ul>
  </li>
</ul>

<p><br /><br /></p>

<h2 id="4-해시-버킷-동적-확장resize">4. 해시 버킷 동적 확장(Resize)</h2>

<ul>
  <li>
    <p>해시 버킷의 개수가 적으면 Collision 으로 인해 성능 손실이 발생한다.</p>
  </li>
  <li>
    <p>Key-Value 쌍 데이터 개수가 일정 개수 이상이 되면 해시 버킷의 개수를 두 배로 늘린다.</p>
  </li>
  <li>
    <p>보통 두 배로 확장하는 임계점은 현재 데이터 개수가 해시 버킷의 개수의 75%가 될 때다.</p>

    <p><code class="language-plaintext highlighter-rouge">load factor</code> = <code class="language-plaintext highlighter-rouge">0.75</code></p>
  </li>
  <li>
    <p>Resizing은 더 큰 버킷을 가지는 array를 새로 만든 다음에, 다시 새로운 array에 hash를 다시 계산해서 복사해준다.</p>
  </li>
</ul>

<p><br /><br /><br /></p>

<h1 id="java-hash-map">(Java) Hash Map</h1>

<ul>
  <li>Hash map은 기존 해시 테이블의 기능을 개선한 신 버전의 해시 테이블</li>
  <li>HashMap은 보조 해시 함수를 사용하기 때문에 Hash Table에 비해 해시 충돌이 덜 발생할 수 있어 성능상 이점이 있다.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">보조 해시 함수</code>는 ‘키’의 해시 값을 변형해 해시 충돌 가능성을 줄이기 위한 것</li>
      <li>HashMap은 먼저 Key 값을 hashcode()라는 메소드를 통해 해시값으로 바꾸고, 이를 버킷 사이즈인 M으로 나눈 나머지가 해시 버킷의 진짜 인덱스가 된다.</li>
    </ul>
  </li>
  <li>키에 대한 해시 값을 사용해 값을 저장하고 조회하며, 키-값 쌍의 개수에 따라 동적으로 크기가 증가하는 Associate Array.</li>
</ul>

<p><br /></p>

<h3 id="hash-table-vs-hash-map">Hash Table vs Hash Map</h3>

<table>
  <thead>
    <tr>
      <th>Hash Table</th>
      <th>Hash Map</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>병렬 처리를 할 때 = 동기화 (멀티 스레드)</td>
      <td>병럴 처리를 하지 않을 때 (단일 스레드)</td>
    </tr>
    <tr>
      <td>Null 값 허용하지 않음</td>
      <td>Null 값 허용</td>
    </tr>
    <tr>
      <td>상대적으로 느리다</td>
      <td>상대적으로 빠르다</td>
    </tr>
  </tbody>
</table>

<p><br /><br /><br /></p>

<h1 id="질문">질문</h1>

<h3 id="직접-주소화-방법을-알고-계시나요-그-방법이-무엇인지-장점과-단점을-설명해주세요">직접 주소화 방법을 알고 계시나요? 그 방법이 무엇인지, 장점과 단점을 설명해주세요.</h3>

<p>직접 주소화 방법은 입력받은 key 값을 그대로 인덱스로 해 value를 저장하는 방법입니다. 키 값으로 바로 접근하기 때문에 속도가 빠르지만, 공간 효율성이 좋지 않고 키 값이 한정된다는 단점이 있습니다.</p>

<p><br /></p>

<h4 id="추가-해당-방법의-단점을-개선한-자료구조는-무엇인가요">(추가) 해당 방법의 단점을 개선한 자료구조는 무엇인가요?</h4>

<p>Hash Table 입니다. 해시 테이블은 해시 함수를 이용해 해시 값을 인덱스로 해서 value를 저장합니다. 해시 함수를 사용함으로 지정한 해시 테이블 크기만큼으로 키값이 변환되어 공간을 더 효율적으로 사용할 수 있습니다.</p>

<p><br /><br /></p>

<h3 id="해시가-무엇인지-시간복잡도는-어떻게-되는지-설명해주세요">해시가 무엇인지, 시간복잡도는 어떻게 되는지 설명해주세요.</h3>

<p>해시는 가변 길의의 데이터를 고정 길이의 데이터로 매핑한 값을 의미하고, 해시 테이블의 해시 변환, 검색, 삭제에 걸리는 시간 복잡도는 이론적으로 O(1)입니다.</p>

<p>하지만 만약 모든 해시 값이 하나로 귀결되는 최악의 경우에는 배열과 마찬가지로 O(N)이 됩니다.</p>

<p><br /><br /></p>

<h3 id="해시테이블은-내부적으로-어떻게-작동하나요">해시테이블은 내부적으로 어떻게 작동하나요?</h3>

<p>해시 테이블은 해시 함수를 이용해 입력된 값의 해시 값을 인덱스로 삼아 저장하고, 동적 배열로 구현되어 있어 사이즈를 늘릴 수 있습니다.</p>

<p><br /><br /></p>

<h3 id="좋은-해시함수는-무엇인가요">좋은 해시함수는 무엇인가요?</h3>

<p>해시 함수는 인덱스를 설정하는 함수이므로, 좋은 해시 함수는 특정 값에 치우치지 않고 해시값을 고르게 만들어내는 함수입니다.</p>

<p><br /><br /></p>

<h3 id="아까-해시-테이블의-시간복잡도가-최악의-경우-on이라고-했는데-충돌을-해결할-수-있는-방법은-무엇인가요">아까 해시 테이블의 시간복잡도가 최악의 경우 O(n)이라고 했는데 충돌을 해결할 수 있는 방법은 무엇인가요?</h3>

<p>우선 해시 함수를 먼저 점검할 것 같습니다. 해시 함수를 수정해 충돌을 최소화할 수 있는지 확인해보고, 그 다음으로 충돌을 대비하기 위해 Chaining 이나 Open Addressing 방법을 사용할 수 있습니다.</p>

<p><br /><br /></p>

<h3 id="충돌-대비를-위한-chaining-과-open-addressing-설명">충돌 대비를 위한 Chaining 과 Open Addressing 설명</h3>

<p>Chaining은 충돌이 된 경우, 링크드 리스트와 같은 자료구조를 사용해 노드를 추가하는 방식입니다.</p>

<p>Open Addressing은 충돌이 된 경우, 빈 해시 테이블에 저장을 하는 방법입니다. 빈 공간을 찾는 방법에는 linear 하거나, quadratic 하게 하는 등의 방법이 있습니다.</p>

<p><br /><br /></p>

<h3 id="open-addressing에서-선형-조사법-이차-조사법의-문제점과-해결방안">Open Addressing에서 선형 조사법, 이차 조사법의 문제점과 해결방안</h3>

<p>선형 조사법과 이차 조사법은 데이터들이 뭉쳐서 저장되는 클러스터링 문제를 야기할 수 있습니다. 이를 해결하기 위해 빈 해시 테이블을 찾을 때 또 다른 해시 함수를 사용해 좀 더 거리의 랜덤성을 부여할 수 있을 것 같습니다.</p>

<p><br /><br /></p>

<h3 id="본인이-충돌이-잦은-경우에-해시함수를-사용한다면-어떤-방식으로-해시테이블을-구성할건가요">본인이 충돌이 잦은 경우에 해시함수를 사용한다면 어떤 방식으로 해시테이블을 구성할건가요?</h3>

<p>만약 해시 테이블이 75% 이상 차 있는 경우라면 테이블 사이즈를 증가해보고, 그래도 문제가 발생한다면 해시 함수를 살펴보거나 해당 데이터를 잘 담을 수 있는 다른 자료 구조가 있는지 찾아볼 것 같습니다.</p>

<p>만약 해시 테이블을 사용해야하는 경우라면 충돌 방지 기법 중 Chaining 을 이진 탐색 트리로 구현해 어떤 경우에도 O(logN) 안에 탐색할 수 있도록 구현할 것 같습니다.</p>

<p><br /><br /></p>

<h2 id="추가-질문-해시-테이블-외-질문">추가 질문 (해시 테이블 외 질문!)</h2>

<h3 id="배열과-링크드리스트가-무엇인지-공통점과-차이점을-기준으로-설명해주세요">배열과 링크드리스트가 무엇인지 공통점과 차이점을 기준으로 설명해주세요.</h3>

<p>배열은 연속된 메모리에 데이터를 저장하는 자료 구조이고, 링크드 리스트는 각 노드가 데이터와 포인터로 구성되어 포인터로 연결되어 있는 자료 구조입니다.</p>

<p>배열과 링크드 리스트 둘 다 데이터를 연속적으로 저장하기 위한 자료 구조입니다. 하지만 배열은 인덱스로 접근이 가능해 탐색이 O(1)로 빠른데 반해 링크드 리스트는 일반적으로 O(N) 시간을 갖습니다.</p>

<p>반면 배열은 크기가 고정적이고 메모리 공간이 낭비되지만 링크드 리스트는 유동적이며 메모리 공간을 낭비하지 않는다는 차이점이 있습니다.</p>

<p><br /></p>

<h4 id="추가-배열은-접근-속도가-빠르다고-했는데-어떻게-그렇게-빠른-접근-속도를-가지나요">(추가) 배열은 접근 속도가 빠르다고 했는데, 어떻게 그렇게 빠른 접근 속도를 가지나요?</h4>

<p>배열은 연속된 메모리에 데이터를 저장하기 때문에 인덱스를 통해서 접근할 수 있어 배열의 특정 위치에 있는 데이터를 한 번에 접근할 수 있습니다.</p>

<p><br /></p>

<h4 id="추가-수정할-때-시간복잡도는-어떻게-되나요">(추가) 수정할 때 시간복잡도는 어떻게 되나요?</h4>

<p>특정 위치의 데이터의 값을 수정한다면 O(1) 이 되고, 삽입과 삭제와 같은 작업이라면 특정 위치에 삽입/삭제 후 나머지 데이터를 뒤로 밀어주거나, 당겨주는 작업이 필요해  일반적으로 O(N) 이 됩니다.</p>

<p><br /></p>

<h4 id="추가-배열에서-인덱스-값-어떻게-계산하나요">(추가) 배열에서 인덱스 값 어떻게 계산하나요?</h4>

<p>int형 배열인 경우에는 4바이트씩 메모리 주소가 떨어지게 되고, 해당 메모리 주소마다 인덱스를 0부터 1씩 증가시켜 계산합니다.</p>

<p><br /></p>

<h3 id="그러면-결국-링크드-리스트는-삽입-삭제-탐색-모두에-on의-시간복잡도를-가지게-되는데-왜-굳이-사용하는-걸까요">그러면 결국 링크드 리스트는 삽입, 삭제, 탐색 모두에 O(n)의 시간복잡도를 가지게 되는데 왜 굳이 사용하는 걸까요?</h3>

<p>배열은 고정된 크기를 갖기 때문에 미리 원소의 개수를 알 수 없을 때 메모리를 효율적으로 사용하기 위해 사용합니다.</p>

<p><br /><br /></p>

<h4 id="추가-어떤-경우에-배열을-사용하고-어떤-경우에-링크드-리스트를-사용할까요">(추가) 어떤 경우에 배열을 사용하고 어떤 경우에 링크드 리스트를 사용할까요?</h4>

<p>데이터 개수가 정해져있고, 검색이 많이 필요한 경우에는 배열을, 데이터 크기가 정해져 있지 않고 삽입과 삭제가 자주 일어날 때는 링크드 리스트를 사용하면 좋을 것 같습니다.</p>

<p><br /><br /></p>

<h3 id="배열과-링크드-리스트는-각각-메모리의-어떤-영역에-저장될까요-이어서-메모리-영역-묻기">배열과 링크드 리스트는 각각 메모리의 어떤 영역에 저장될까요? (이어서 메모리 영역 묻기)</h3>

<p>배열은 컴파일 단계에서 stack 이나 data영역에 메모리 할당이 일어나고, 링크드 리스트는 런타임에 새로운 노드가 추가될 때마다 heap 영역에서 할당되어 저장됩니다.</p>

<p>만약 동적 배열이라면 heap 영역에 할당될 것입니다.</p>

<p><br /><br /></p>

<h3 id="priority-queue에-대해서-들어보셨나요-어떻게-구현하나요">Priority Queue에 대해서 들어보셨나요? 어떻게 구현하나요?</h3>

<p>네, 큐는 먼저 들어온 순서대로 나가는 FIFO 형 자료구조 입니다. 우선순위 큐는 들어온 순서대로가 아닌 우선 순위가 높은 순서대로 나가는 형태의 자료구조입니다.</p>

<p>구현은 완전 이진트리의 일종인 heap으로 구현합니다.</p>

<p><br /><br /></p>

<h4 id="추가-왜-그렇게-구현하나요">(추가) 왜 그렇게 구현하나요?</h4>

<p>최소 힙이나 최대 힙을 사용하면 데이터를 넣는 것만으로도 이미 우선 순위 큐에 맞게 정렬이 되기 때문입니다.</p>

<p><br /><br /><br /></p>

<h1 id="references">References</h1>

<ul>
  <li>
    <p><a href="http://wiki.hash.kr/index.php/%ED%95%B4%EC%8B%9C">wiki.hash/해시</a></p>
  </li>
  <li><a href="https://goodgid.github.io/Hash-Table/">Hash-Table</a></li>
  <li><a href="https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/DataStructure#hash-table">JaeYeopHan/Interview…/Hash Table</a></li>
  <li><a href="https://ratsgo.github.io/data%20structure&amp;algorithm/2017/10/25/hash/">ratsgo/hash table</a></li>
  <li>
    <p><a href="https://velog.io/@mooh2jj/Hash%EC%9D%98-%EA%B0%9C%EB%85%90-%EB%B0%8F-%EC%84%A4%EB%AA%85">Hash 함수</a></p>
  </li>
  <li><a href="https://velog.io/@dlgosla/CS-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%ED%95%B4%EC%8B%9C-%ED%85%8C%EC%9D%B4%EB%B8%94-Hash-Table-%EA%B0%9C%EB%85%90-%EC%A0%95%EB%A6%AC">CS-자료구조-해시-테이블</a>직</li>
</ul>]]></content><author><name>pino</name></author><category term="[&quot;CS&quot;, &quot;\uC790\uB8CC\uAD6C\uC870&quot;]" /><summary type="html"><![CDATA[TL;DR]]></summary></entry><entry><title type="html">열아홉</title><link href="/til/2022/2022-10/2022/10/20/TIL_019.html" rel="alternate" type="text/html" title="열아홉" /><published>2022-10-20T23:45:42+09:00</published><updated>2022-10-20T23:45:42+09:00</updated><id>/til/2022/2022-10/2022/10/20/TIL_019</id><content type="html" xml:base="/til/2022/2022-10/2022/10/20/TIL_019.html"><![CDATA[<h2 id="코테-base-step">[코테] BASE STEP</h2>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">이것이 취업을 위한 코딩 테스트다</code> 의 부록 A 읽고 정리</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">구현</code>, <code class="language-plaintext highlighter-rouge">BFS/DFS</code> 기본 문제 풀이</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">구현</code>의 경우 기본 문제들은 크게 어렵다고 느껴지지는 않았는데, <code class="language-plaintext highlighter-rouge">BFS/DFS</code> 는 몇 문제 더 풀어봐야 활용하는 것에 감을 잡을 것 같다.</p>

    <p>특히 구현에도 dx, dy 사용해서 이동하는 문제가 있고, 탐색에서도 이동하는 문제가 있어서 이걸 어떻게 구분할 것인지 생각을 해봐야될 것 같다.</p>
  </li>
  <li>
    <p>DFS : 재귀적 특징과 백트래킹 이용한 모든 경우를 하나하나 전부 탐색하는 경우 선호(대표적으로 조합 순열 구현)</p>
  </li>
  <li>
    <p>BFS : 큐 사용해 Depth 특징 이용한 문제 경우 선호 (대표적으로 최단경로)</p>
  </li>
</ul>

<p><br /><br /></p>

<h2 id="cs-스터디-아카이빙">[CS 스터디] 아카이빙</h2>

<ul>
  <li>DB - <code class="language-plaintext highlighter-rouge">NoSQL, 리플리케이션 vs 클러스터링, DB 샤딩</code> 포스트 모의 면접 질문들 정리하기</li>
  <li>DS - <code class="language-plaintext highlighter-rouge">Hash Table</code> 포스트 모의 면접 질문들 정리하기</li>
  <li>노션 페이지에도 아카이빙 완료!</li>
</ul>

<p>=&gt; 다시 한 번 총 정리할 필요가 있다!</p>

<p><br /><br /></p>

<h2 id="ml-스터디-아카이빙">[ML 스터디] 아카이빙</h2>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">ch5</code>, <code class="language-plaintext highlighter-rouge">비지도 학습 톺아보기</code> 아카이빙 후다닥 proto 완료</p>

    <p>-&gt; 좀 더 다듬을 필요 있다.</p>
  </li>
</ul>

<p><br /><br /></p>

<h2 id="덧">덧</h2>

<ul>
  <li>
    <p>카카오 자소서 작성하던게 무슨 이유에선지 날아가 버렸다.. 훨훨..</p>

    <p>자료 백업은 정신 건강을 위해 꼭 해두기로 하자 ^^</p>
  </li>
</ul>]]></content><author><name>pino</name></author><category term="[&quot;TIL&quot;, 2022, &quot;2022-10&quot;]" /><summary type="html"><![CDATA[[코테] BASE STEP]]></summary></entry><entry><title type="html">열여덟</title><link href="/til/2022/2022-10/2022/10/20/TIL_018.html" rel="alternate" type="text/html" title="열여덟" /><published>2022-10-20T23:45:42+09:00</published><updated>2022-10-20T23:45:42+09:00</updated><id>/til/2022/2022-10/2022/10/20/TIL_018</id><content type="html" xml:base="/til/2022/2022-10/2022/10/20/TIL_018.html"><![CDATA[<h2 id="코테-base-step">[코테] BASE STEP</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">이것이 취업을 위한 코딩 테스트다</code> 의 부록 읽고 정리 시작</li>
</ul>

<h2 id="영어-experiencing-god-ch23">[영어] Experiencing God ch23</h2>

<ul>
  <li>I got a flu shot</li>
  <li>We were able to build much closer relationship without the age barrier</li>
  <li>
    <p>We are the catalyst. Happy Virus.</p>
  </li>
  <li>Talk about God’s activity !!!!</li>
</ul>

<p><br /><br /></p>

<h2 id="마스터봇-한국어-tts-모델-학습">[마스터봇] 한국어 TTS 모델 학습</h2>

<ul>
  <li>테스트 결과 이전 데이터로 모델 만들어서 사용하기로 결정</li>
  <li>Bahn 영어 모델 추가로 작업해야 한다고 해서 전처리 작업 준비</li>
</ul>

<p><br /><br /></p>

<h2 id="덧">덧</h2>

<ul>
  <li>자기소개서 작성하는게 생각보다 오래 걸린다. 😂</li>
</ul>]]></content><author><name>pino</name></author><category term="[&quot;TIL&quot;, 2022, &quot;2022-10&quot;]" /><summary type="html"><![CDATA[[코테] BASE STEP]]></summary></entry><entry><title type="html">열일곱</title><link href="/til/2022/2022-10/2022/10/19/TIL_017.html" rel="alternate" type="text/html" title="열일곱" /><published>2022-10-19T23:45:42+09:00</published><updated>2022-10-19T23:45:42+09:00</updated><id>/til/2022/2022-10/2022/10/19/TIL_017</id><content type="html" xml:base="/til/2022/2022-10/2022/10/19/TIL_017.html"><![CDATA[<h4 id="20221006--20221019-14days">2022.10.06 ~ 2022.10.19 (14days)</h4>

<p><br /></p>

<h2 id="cs-면접-스터디-스터디-준비">[CS 면접 스터디] 스터디 준비</h2>

<ul>
  <li>5주차 DB : <code class="language-plaintext highlighter-rouge">무결성 제약 조건/트랜잭션/동시성 제어</code>, <code class="language-plaintext highlighter-rouge">관계형 DBMS/정규화</code>, <code class="language-plaintext highlighter-rouge">NoSQL/클러스터링vs리플리케이션/DB샤딩</code>, <code class="language-plaintext highlighter-rouge">인덱스/B-Tree/Join</code> 키워드 준비</li>
  <li>발표 10분 + 개인 면접 15분 + 피드백 약 10분 진행</li>
  <li>DB 부분은 SQL 간단한 문법도 알아두면 좋을 것 같고, 실제 프로젝트에서 사용한 DB 위주로 한 번 더 자세히 정리해야겠다.</li>
</ul>

<p><br /></p>

<ul>
  <li>6주차 자료구조 : <code class="language-plaintext highlighter-rouge">트리</code>, <code class="language-plaintext highlighter-rouge">그래프</code>, <code class="language-plaintext highlighter-rouge">해시 테이블</code>, <code class="language-plaintext highlighter-rouge">정렬알고리즘</code> 키워드 준비</li>
  <li>발표 10분 + 개인 면접 15분 + 피드백 약 10분 진행</li>
  <li>자료구조는 면접 시작에서 물어보기 좋고, 어디서나 사용되기 때문에 더 잘 준비해둘 것!</li>
</ul>

<p><br /></p>

<ul>
  <li>면접할 때 웃는 얼굴로, 밝은 분위기 유지하기! - <strong>3번째 듣는 피드백</strong>!!</li>
</ul>

<p><br /><br /></p>

<h2 id="ml-면접-스터디-스터디-준비">[ML 면접 스터디] 스터디 준비</h2>

<ul>
  <li>ch6 확률 그래프 모델 : <code class="language-plaintext highlighter-rouge">결합확률분포</code>, <code class="language-plaintext highlighter-rouge">확률 그래프의 표현</code>, <code class="language-plaintext highlighter-rouge">생성모델과 판별모델</code>, <code class="language-plaintext highlighter-rouge">마르코프 모델</code>, <code class="language-plaintext highlighter-rouge">토픽 모델</code></li>
  <li>주제가 어렵고 생소해서… 개념만 정리해두고 시간이 될 때 다시 살펴봐야겠다.</li>
  <li>아니면 자연어처리에서 사용되는 토픽 모델 등 관련 모델만 따로 찾아봐야겠다.</li>
</ul>

<p><br /></p>

<ul>
  <li>ch7 최적화 알고리즘 : <code class="language-plaintext highlighter-rouge">손실함수</code>, <code class="language-plaintext highlighter-rouge">최적화 문제란</code>, <code class="language-plaintext highlighter-rouge">최적화 알고리즘</code>, <code class="language-plaintext highlighter-rouge">경사하강법</code>, <code class="language-plaintext highlighter-rouge">확률적 경사하강법</code>, <code class="language-plaintext highlighter-rouge">L1 정규화</code></li>
  <li>개인 면접 15분 + 피드백 10-15분 진행</li>
  <li>최적화는 머신러닝과 딥러닝에서 굉장히 중요하고, 또 수식적인 부분이 많이 들어가기 때문에 잘 정리해둘 것!!</li>
  <li>특히 최적화와 함께 평가 방법도 같이 정리해둘 것.</li>
</ul>

<p><br /><br /></p>

<h2 id="마스터봇-한국어-tts-모델-학습">[마스터봇] 한국어 TTS 모델 학습</h2>

<ul>
  <li>현재까지 노이즈 데이터 : 2 Eden / 7 Seowon
    <ul>
      <li>노이즈 발생 원인을 찾아야 함 -&gt; 파열음으로 인한 공기소리(?)를 원인으로 추정 중</li>
      <li>이전 데이터로 모델을 대체할 수 있을 지 가능성 파악하기</li>
    </ul>
  </li>
</ul>

<p><br /><br /></p>

<h2 id="덧">덧</h2>

<ul>
  <li>사공민 &amp; 해진 서울 나들이</li>
  <li>카카오 인턴 지원하기!</li>
</ul>]]></content><author><name>pino</name></author><category term="[&quot;TIL&quot;, 2022, &quot;2022-10&quot;]" /><summary type="html"><![CDATA[2022.10.06 ~ 2022.10.19 (14days)]]></summary></entry><entry><title type="html">열여섯</title><link href="/til/2022/2022-10/2022/10/05/TIL_016.html" rel="alternate" type="text/html" title="열여섯" /><published>2022-10-05T23:45:42+09:00</published><updated>2022-10-05T23:45:42+09:00</updated><id>/til/2022/2022-10/2022/10/05/TIL_016</id><content type="html" xml:base="/til/2022/2022-10/2022/10/05/TIL_016.html"><![CDATA[<h2 id="cs-면접-스터디-스터디-준비">[CS 면접 스터디] 스터디 준비</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">HTTP/HTTPS</code>, <code class="language-plaintext highlighter-rouge">쿠키/세션/JWT</code>, <code class="language-plaintext highlighter-rouge">SSL/TLS/HSTS</code>, <code class="language-plaintext highlighter-rouge">웹 주소/렌더링 과정</code> 각 포스트 읽고 정리 + 코멘트 남기기 + 질문 리스트업</li>
  <li>발표 10분 + 개인 면접 15분 + 피드백 약 10분 진행</li>
  <li>네트워크는 다 연결되어 있어서 전체적인 흐름을 정리하는게 좋을 것 같다.
    <ul>
      <li>백엔드인지 프론트인지에 따라 추가 정리하기</li>
    </ul>
  </li>
</ul>

<p><br /><br /></p>

<h2 id="마스터봇-한국어-tts-데이터셋-전처리">[마스터봇] 한국어 TTS 데이터셋 전처리</h2>

<ul>
  <li>eden 모델이 2000epoch 넘어가자 노이즈가 더 심해짐..</li>
  <li>데이터의 문제인가? 음..
    <ul>
      <li>berry 학습해보니 400 epoch 인데도 부드러운거 보면 데이터의 문제가 맞는 것으로 판단 됨</li>
    </ul>
  </li>
</ul>

<p><br /><br /></p>

<h2 id="덧">덧</h2>

<ul>
  <li>표현, 表現 : 말이나 행동으로 드러내어 나타내는 것.</li>
  <li>감정, 感情 : 어떤 현상이나 일에 대하여 일어나는 마음이나 느끼는 기분</li>
</ul>]]></content><author><name>pino</name></author><category term="[&quot;TIL&quot;, 2022, &quot;2022-10&quot;]" /><summary type="html"><![CDATA[[CS 면접 스터디] 스터디 준비]]></summary></entry><entry><title type="html">열다섯</title><link href="/til/2022/2022-10/2022/10/04/TIL_015.html" rel="alternate" type="text/html" title="열다섯" /><published>2022-10-04T23:45:42+09:00</published><updated>2022-10-04T23:45:42+09:00</updated><id>/til/2022/2022-10/2022/10/04/TIL_015</id><content type="html" xml:base="/til/2022/2022-10/2022/10/04/TIL_015.html"><![CDATA[<h2 id="ml-면접-스터디-스터디-준비">[ML 면접 스터디] 스터디 준비</h2>

<ul>
  <li>키워드 : <code class="language-plaintext highlighter-rouge">비지도 학습</code>, <code class="language-plaintext highlighter-rouge">K-Means clustering</code>, <code class="language-plaintext highlighter-rouge">가우시안 혼합 모델</code>, <code class="language-plaintext highlighter-rouge">SOM(자기 조직화 지도)</code>, <code class="language-plaintext highlighter-rouge">클러스터링 평가 방법</code></li>
  <li>각 키워드에 대한 질문 리스트업</li>
  <li>개인 면접 15분 + 피드백 5~10분씩 진행</li>
  <li>추가 학습해야할 부분이 많다.
    <ol>
      <li>가우시안 혼합 모델의 학습 과정(정확히는 수식), SOM에 대한 개념</li>
      <li>군집화 외 비지도학습의 활용처</li>
      <li>클러스터링 알고리즘 평가 관련 구조화</li>
    </ol>
  </li>
</ul>

<p><br /></p>

<h4 id="feedback">Feedback</h4>

<p>개인 피드백은 많지 않았고, 느낀점 위주로 정리</p>

<ul>
  <li>
    <p>“클러스터링 알고리즘에 어떤 것들이 있나요?”라고 물었는데 “모른다” 라는 답변이 나오면.. 추가 질문 자체가 막힌다. 이래서 면접관이 노력하는데도 면접이 빨리 끝나는 경우가 있는건가 싶었다. 물론 스터디에서는 키워드가 정해져있기 때문에 더 곤란한 면도 있었다.</p>

    <p><strong>-&gt; 머신러닝과 딥러닝, 특히 본인의 포트폴리오와 관계되는 개념들은 꼭 잘 정리해둘 것!</strong></p>
  </li>
  <li>
    <p>어떤 질문을 했을 때 개념에 대한 정의를 먼저 답변하지 않으면 횡설수설하게 되고, 또 그것이 내용 정리가 잘 안되었다는 느낌을 준다.</p>

    <p>-&gt; 개념과 용어의 깔끔한 정의를 잘 정리해두자.</p>
  </li>
  <li>
    <p><strong>모르거나 정리되지 않은 상태일 때,</strong> 알고 있는 점과 모르는 점을 말하고 “이러이러한 방식으로 풀어나가려고 했다~”는 식의 답변이 좋았다.</p>
  </li>
</ul>

<p><br /><br /></p>

<h2 id="cs-면접-스터디-스터디-준비">[CS 면접 스터디] 스터디 준비</h2>

<ul>
  <li>OSI 7계층에 대한 질문 정리하기 (깃헙 포스트에 추가 + 노션 테이블 추가)</li>
  <li><code class="language-plaintext highlighter-rouge">GET vs POST</code> 정리해서 포스팅하기 (개인 블로그용)</li>
</ul>

<p><br /><br /></p>

<h2 id="마스터봇-한국어-tts-데이터셋-전처리">[마스터봇] 한국어 TTS 데이터셋 전처리</h2>

<ul>
  <li>eden 모델이 2000epoch 넘어가자 노이즈가 더 심해짐..</li>
  <li>데이터의 문제인가? 음..</li>
</ul>

<p><br /><br /></p>

<h2 id="덧">덧</h2>

<ul>
  <li>식단 조절하기 시작!</li>
</ul>]]></content><author><name>pino</name></author><category term="[&quot;TIL&quot;, 2022, &quot;2022-10&quot;]" /><summary type="html"><![CDATA[[ML 면접 스터디] 스터디 준비]]></summary></entry><entry><title type="html">열넷</title><link href="/til/2022/2022-10/2022/10/03/TIL_014.html" rel="alternate" type="text/html" title="열넷" /><published>2022-10-03T23:45:42+09:00</published><updated>2022-10-03T23:45:42+09:00</updated><id>/til/2022/2022-10/2022/10/03/TIL_014</id><content type="html" xml:base="/til/2022/2022-10/2022/10/03/TIL_014.html"><![CDATA[<h4 id="기간--0929--1003">기간 : 09.29 ~ 10.03</h4>

<h2 id="ml-면접-스터디-스터디-준비">[ML 면접 스터디] 스터디 준비</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">비지도 학습 톺아보기</code> 포스팅</li>
  <li>비지도 학습에 대해 정리하고, 예상 질문 리스트업</li>
</ul>

<p><br /><br /></p>

<h2 id="cs-면접-스터디-스터디-준비">[CS 면접 스터디] 스터디 준비</h2>

<ul>
  <li>네트워크 <code class="language-plaintext highlighter-rouge">쿠키, 세션, JWT, 캐시</code> 포스팅</li>
  <li>개념에 대해 각각 정리하고, 예상 질문 리스트업</li>
</ul>

<p><br /><br /></p>

<h2 id="마스터봇-한국어-tts-데이터셋-전처리">[마스터봇] 한국어 TTS 데이터셋 전처리</h2>

<ul>
  <li>
    <p>한국어 TTS 데이터셋 재요청한 것 전처리 진행 (<code class="language-plaintext highlighter-rouge">eden</code>, <code class="language-plaintext highlighter-rouge">berry</code>, <code class="language-plaintext highlighter-rouge">seowon</code>, <code class="language-plaintext highlighter-rouge">juhyung</code>)</p>
  </li>
  <li>
    <p>eden 모델 학습 시작</p>

    <p>-&gt; 1600 epoch까지는 아직 피치가 불안정하고 노이즈가 많이 발생함</p>
  </li>
</ul>

<p><br /><br /></p>

<h2 id="덧">덧</h2>

<ul>
  <li>Free will kicks in anytime, and He never say “No”.</li>
  <li>마음 속 가시는 나의 최선이 내게 있지 않았기 때문이었다.</li>
  <li>
    <p>비비안 마이어 사진전 관람!</p>
  </li>
  <li>
    <p>경제와 세계 정세에 대한 큰 흐름을 볼 수 있는 시각은 정말 중요하다. 키우자!</p>
  </li>
  <li>젖은 돈은 시간을 두 배로 만드는 능력이 있었다..</li>
</ul>]]></content><author><name>pino</name></author><category term="[&quot;TIL&quot;, 2022, &quot;2022-10&quot;]" /><summary type="html"><![CDATA[기간 : 09.29 ~ 10.03]]></summary></entry><entry><title type="html">열셋</title><link href="/til/2022/2022-09/2022/09/28/TIL_013.html" rel="alternate" type="text/html" title="열셋" /><published>2022-09-28T23:45:42+09:00</published><updated>2022-09-28T23:45:42+09:00</updated><id>/til/2022/2022-09/2022/09/28/TIL_013</id><content type="html" xml:base="/til/2022/2022-09/2022/09/28/TIL_013.html"><![CDATA[<h2 id="cs-면접-스터디-질문-정리">[CS 면접 스터디] 질문 정리</h2>

<ul>
  <li>키워드 : <code class="language-plaintext highlighter-rouge">TCP-UDP</code> <code class="language-plaintext highlighter-rouge">GET vs POST</code> <code class="language-plaintext highlighter-rouge">TCP 3-way-hand-shake</code> <code class="language-plaintext highlighter-rouge">OSI 7계층</code></li>
  <li>
    <p>키워드 설명 15분 + 면접 20분 + 피드백 5분씩 진행</p>
  </li>
  <li>OSI 7계층이란 키워드가 개념적인 것이 많기 때문에, <code class="language-plaintext highlighter-rouge">실제 응용 프로그램에서 어떻게 전송이 이루어지나</code> 와 같은 예시로 이해해두자.</li>
  <li>본인이 경험한 프로젝트와 연관지어서 개념을 설명해보기 (특히 <code class="language-plaintext highlighter-rouge">REST API</code> 같은 키워드)</li>
</ul>

<p><br /></p>

<h4 id="feedback">Feedback</h4>

<ul>
  <li>침착해보이지만 무표정이라 딱딱한 분위기 -&gt; 좀 더 밝은 분위기로!</li>
</ul>

<p><br /><br /></p>

<h2 id="ml-면접-스터디-스터디-준비">[ML 면접 스터디] 스터디 준비</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">PCA</code> 키워드에 대한 질문 정리</li>
</ul>

<p><br /><br /></p>

<h2 id="덧">덧</h2>

<ul>
  <li>사유는 허락된 자유이면서 덫과 같다. 현재의 한 조각만 볼 수 없어서 그런가보다.</li>
</ul>]]></content><author><name>pino</name></author><category term="[&quot;TIL&quot;, 2022, &quot;2022-09&quot;]" /><summary type="html"><![CDATA[[CS 면접 스터디] 질문 정리]]></summary></entry></feed>